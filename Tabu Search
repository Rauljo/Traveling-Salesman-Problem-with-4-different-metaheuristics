{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "3d57d457",
   "metadata": {},
   "source": [
    "\n",
    "# Práctica 2: Metaheurísticas basadas en trayectorias: Tabu Search"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dc9d72a9",
   "metadata": {},
   "source": [
    "<center><h3>\n",
    "    Raúl José Salgado García\n",
    "</h3></center>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8087aede",
   "metadata": {
    "tags": []
   },
   "source": [
    "# Instrucciones"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a351019b",
   "metadata": {},
   "source": [
    "Igual que en la Práctica 1, utilizaremos un **Jupyter Notebook** para la resolución de esta práctica.\n",
    "\n",
    "Como ya sabéis, nos permite ir ejecutando celdas de código poco a poco, así como generar automáticamente un informe bien formateado de la práctica. Aun así, a continuación tenéis unas breves instrucciones sobre como funciona:\n",
    "\n",
    "* Puedes añadir una celda con el botón **\"Insert\"** de la barra de herramentas, y cambiar su tipo con **\"Cell > Cell Type\"**\n",
    "* Para ejecutar una celda de código, la seleccionaremos y pulsaremos el botón **\"▶ Run\"** de la barra de herramentas.\n",
    "* Para pasar el documento a HTML, seleccionaremos **\"File > Download as > HTML (.html)\"**\n",
    "\n",
    "Sigue este guión hasta el final. Ejecuta el código proporcionado paso a paso comprendiendo lo que estás haciendo y reflexionando sobre los resultados. Habrá preguntas intercaladas a lo largo del guión, responde a todas ellas en la sección reservada para ese fin: **\"Respuestas a los cuestionarios\"**. Por favor, no modifiques ninguna linea de código excepto cuando se te pida explícitamente.\n",
    "\n",
    "No olvides insertar tu **nombre y apellidos** en la celda superior.\n",
    "\n",
    "IMPORTANTE: Se te pedirán dos implementaciones del algoritmo de Búsqueda Tabú, una primera implementación obligatoria y una implementación mejorada optativa. Escribe el código de tu o tus soluciones en las celdas que se indican para ello. Además, a lo largo de la práctica se plantearán varias preguntas que debéis responder en la parte inferior del documento, incluyendo las celdas que veáis necesarias (si hacéis referencia a partes concretas de vuestro código, etc) para reponder a ellas."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c804f80",
   "metadata": {},
   "source": [
    "## Entrega de la práctica"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "797d20ec",
   "metadata": {},
   "source": [
    "La fecha límite de entrega será la indicada en el Campus Virtual. La entrega consistirá de un único archivo comprimido con nombre `APELIDOS_NOME_BusquedaTabu.zip` que contenga los seguientes ficheros:\n",
    "\n",
    " * `APELIDOS_NOME_BusquedaTabu.html`: Archivo HTML fruto de la exportación del presente Notebook, con las preguntas respondidas al final del documento.\n",
    " * `APELIDOS_NOME_BusquedaTabu.ipynb`: Archivo fuente Jupyter Notebook.\n",
    " * Archivo de datos de los problema utilizados en la resolución.\n",
    " \n",
    " ---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f7f872a1",
   "metadata": {
    "tags": []
   },
   "source": [
    "\n",
    "# Preliminares adicionales sobre Python"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c2f982c",
   "metadata": {},
   "source": [
    "Además de lo visto en las prácticas anteriores, conviene familiarizarse con algunas funciones disponibles en Python que pueden resultarte útiles más adelante en la realización de esta práctica y en el uso del lenguaje en general.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "440200d4",
   "metadata": {},
   "source": [
    "Por ejemplo, cuando necesitas consultar documentación sobre paquetes Python, conviene que conozcas la versión que estás utilizando en tu entorno para poder encontrar las especificidades de cada *release*. Fíjate que en la sección *Docs by version* de la web https://docs.python.org/3/ puedes seleccionar los documentos de referencia de la versión.\n",
    "\n",
    "Para averiguar la versión que está ejecutando este Jupyter Noteboook puedes emplear las siguientes líneas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d6354e9a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3.9.7\n"
     ]
    }
   ],
   "source": [
    "from platform import python_version\n",
    "\n",
    "print(python_version())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a9c96428",
   "metadata": {},
   "source": [
    "Un paquete interesante puede ser statistics. Conociendo la versión, puedes puedes consultar la documentación y la lista completa de funciones disponibles: https://docs.python.org/3/library/statistics.html\n",
    "\n",
    "A modo ilustrativo, puedes obtener estadísticos sobre series de datos de la siguiente forma.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "371102aa",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3 1.5811388300841898\n",
      "3.3 1.5751984002023365\n"
     ]
    }
   ],
   "source": [
    "import statistics\n",
    "\n",
    "# ejemplo de obtención de medias y desviaciones típicas\n",
    "listav = [1, 2, 3, 4, 5]\n",
    "media = statistics.mean(listav)\n",
    "desvtip = statistics.stdev(listav)\n",
    "print(media, desvtip)\n",
    "\n",
    "listav = [1.0, 2.5, 3.75, 4.25, 5]\n",
    "media = statistics.mean(listav)\n",
    "desvtip = statistics.stdev(listav)\n",
    "print(media, desvtip)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e4c8a62e",
   "metadata": {},
   "source": [
    "Otro paquete que puede resultarte útil a la hora de crear un informe o documentar tu práctica puede ser `matplotlib.pyplot`, que permite hacer gráficas de manera integrada en el propio Notebook. Puedes consultar sus capacidades en https://matplotlib.org/stable/gallery/index.html\n",
    "\n",
    "Veámos un ejemplo ilustrativo."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "b4a134cd",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/javascript": [
       "/* Put everything inside the global mpl namespace */\n",
       "/* global mpl */\n",
       "window.mpl = {};\n",
       "\n",
       "mpl.get_websocket_type = function () {\n",
       "    if (typeof WebSocket !== 'undefined') {\n",
       "        return WebSocket;\n",
       "    } else if (typeof MozWebSocket !== 'undefined') {\n",
       "        return MozWebSocket;\n",
       "    } else {\n",
       "        alert(\n",
       "            'Your browser does not have WebSocket support. ' +\n",
       "                'Please try Chrome, Safari or Firefox ≥ 6. ' +\n",
       "                'Firefox 4 and 5 are also supported but you ' +\n",
       "                'have to enable WebSockets in about:config.'\n",
       "        );\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure = function (figure_id, websocket, ondownload, parent_element) {\n",
       "    this.id = figure_id;\n",
       "\n",
       "    this.ws = websocket;\n",
       "\n",
       "    this.supports_binary = this.ws.binaryType !== undefined;\n",
       "\n",
       "    if (!this.supports_binary) {\n",
       "        var warnings = document.getElementById('mpl-warnings');\n",
       "        if (warnings) {\n",
       "            warnings.style.display = 'block';\n",
       "            warnings.textContent =\n",
       "                'This browser does not support binary websocket messages. ' +\n",
       "                'Performance may be slow.';\n",
       "        }\n",
       "    }\n",
       "\n",
       "    this.imageObj = new Image();\n",
       "\n",
       "    this.context = undefined;\n",
       "    this.message = undefined;\n",
       "    this.canvas = undefined;\n",
       "    this.rubberband_canvas = undefined;\n",
       "    this.rubberband_context = undefined;\n",
       "    this.format_dropdown = undefined;\n",
       "\n",
       "    this.image_mode = 'full';\n",
       "\n",
       "    this.root = document.createElement('div');\n",
       "    this.root.setAttribute('style', 'display: inline-block');\n",
       "    this._root_extra_style(this.root);\n",
       "\n",
       "    parent_element.appendChild(this.root);\n",
       "\n",
       "    this._init_header(this);\n",
       "    this._init_canvas(this);\n",
       "    this._init_toolbar(this);\n",
       "\n",
       "    var fig = this;\n",
       "\n",
       "    this.waiting = false;\n",
       "\n",
       "    this.ws.onopen = function () {\n",
       "        fig.send_message('supports_binary', { value: fig.supports_binary });\n",
       "        fig.send_message('send_image_mode', {});\n",
       "        if (fig.ratio !== 1) {\n",
       "            fig.send_message('set_dpi_ratio', { dpi_ratio: fig.ratio });\n",
       "        }\n",
       "        fig.send_message('refresh', {});\n",
       "    };\n",
       "\n",
       "    this.imageObj.onload = function () {\n",
       "        if (fig.image_mode === 'full') {\n",
       "            // Full images could contain transparency (where diff images\n",
       "            // almost always do), so we need to clear the canvas so that\n",
       "            // there is no ghosting.\n",
       "            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);\n",
       "        }\n",
       "        fig.context.drawImage(fig.imageObj, 0, 0);\n",
       "    };\n",
       "\n",
       "    this.imageObj.onunload = function () {\n",
       "        fig.ws.close();\n",
       "    };\n",
       "\n",
       "    this.ws.onmessage = this._make_on_message_function(this);\n",
       "\n",
       "    this.ondownload = ondownload;\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._init_header = function () {\n",
       "    var titlebar = document.createElement('div');\n",
       "    titlebar.classList =\n",
       "        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';\n",
       "    var titletext = document.createElement('div');\n",
       "    titletext.classList = 'ui-dialog-title';\n",
       "    titletext.setAttribute(\n",
       "        'style',\n",
       "        'width: 100%; text-align: center; padding: 3px;'\n",
       "    );\n",
       "    titlebar.appendChild(titletext);\n",
       "    this.root.appendChild(titlebar);\n",
       "    this.header = titletext;\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};\n",
       "\n",
       "mpl.figure.prototype._root_extra_style = function (_canvas_div) {};\n",
       "\n",
       "mpl.figure.prototype._init_canvas = function () {\n",
       "    var fig = this;\n",
       "\n",
       "    var canvas_div = (this.canvas_div = document.createElement('div'));\n",
       "    canvas_div.setAttribute(\n",
       "        'style',\n",
       "        'border: 1px solid #ddd;' +\n",
       "            'box-sizing: content-box;' +\n",
       "            'clear: both;' +\n",
       "            'min-height: 1px;' +\n",
       "            'min-width: 1px;' +\n",
       "            'outline: 0;' +\n",
       "            'overflow: hidden;' +\n",
       "            'position: relative;' +\n",
       "            'resize: both;'\n",
       "    );\n",
       "\n",
       "    function on_keyboard_event_closure(name) {\n",
       "        return function (event) {\n",
       "            return fig.key_event(event, name);\n",
       "        };\n",
       "    }\n",
       "\n",
       "    canvas_div.addEventListener(\n",
       "        'keydown',\n",
       "        on_keyboard_event_closure('key_press')\n",
       "    );\n",
       "    canvas_div.addEventListener(\n",
       "        'keyup',\n",
       "        on_keyboard_event_closure('key_release')\n",
       "    );\n",
       "\n",
       "    this._canvas_extra_style(canvas_div);\n",
       "    this.root.appendChild(canvas_div);\n",
       "\n",
       "    var canvas = (this.canvas = document.createElement('canvas'));\n",
       "    canvas.classList.add('mpl-canvas');\n",
       "    canvas.setAttribute('style', 'box-sizing: content-box;');\n",
       "\n",
       "    this.context = canvas.getContext('2d');\n",
       "\n",
       "    var backingStore =\n",
       "        this.context.backingStorePixelRatio ||\n",
       "        this.context.webkitBackingStorePixelRatio ||\n",
       "        this.context.mozBackingStorePixelRatio ||\n",
       "        this.context.msBackingStorePixelRatio ||\n",
       "        this.context.oBackingStorePixelRatio ||\n",
       "        this.context.backingStorePixelRatio ||\n",
       "        1;\n",
       "\n",
       "    this.ratio = (window.devicePixelRatio || 1) / backingStore;\n",
       "\n",
       "    var rubberband_canvas = (this.rubberband_canvas = document.createElement(\n",
       "        'canvas'\n",
       "    ));\n",
       "    rubberband_canvas.setAttribute(\n",
       "        'style',\n",
       "        'box-sizing: content-box; position: absolute; left: 0; top: 0; z-index: 1;'\n",
       "    );\n",
       "\n",
       "    // Apply a ponyfill if ResizeObserver is not implemented by browser.\n",
       "    if (this.ResizeObserver === undefined) {\n",
       "        if (window.ResizeObserver !== undefined) {\n",
       "            this.ResizeObserver = window.ResizeObserver;\n",
       "        } else {\n",
       "            var obs = _JSXTOOLS_RESIZE_OBSERVER({});\n",
       "            this.ResizeObserver = obs.ResizeObserver;\n",
       "        }\n",
       "    }\n",
       "\n",
       "    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {\n",
       "        var nentries = entries.length;\n",
       "        for (var i = 0; i < nentries; i++) {\n",
       "            var entry = entries[i];\n",
       "            var width, height;\n",
       "            if (entry.contentBoxSize) {\n",
       "                if (entry.contentBoxSize instanceof Array) {\n",
       "                    // Chrome 84 implements new version of spec.\n",
       "                    width = entry.contentBoxSize[0].inlineSize;\n",
       "                    height = entry.contentBoxSize[0].blockSize;\n",
       "                } else {\n",
       "                    // Firefox implements old version of spec.\n",
       "                    width = entry.contentBoxSize.inlineSize;\n",
       "                    height = entry.contentBoxSize.blockSize;\n",
       "                }\n",
       "            } else {\n",
       "                // Chrome <84 implements even older version of spec.\n",
       "                width = entry.contentRect.width;\n",
       "                height = entry.contentRect.height;\n",
       "            }\n",
       "\n",
       "            // Keep the size of the canvas and rubber band canvas in sync with\n",
       "            // the canvas container.\n",
       "            if (entry.devicePixelContentBoxSize) {\n",
       "                // Chrome 84 implements new version of spec.\n",
       "                canvas.setAttribute(\n",
       "                    'width',\n",
       "                    entry.devicePixelContentBoxSize[0].inlineSize\n",
       "                );\n",
       "                canvas.setAttribute(\n",
       "                    'height',\n",
       "                    entry.devicePixelContentBoxSize[0].blockSize\n",
       "                );\n",
       "            } else {\n",
       "                canvas.setAttribute('width', width * fig.ratio);\n",
       "                canvas.setAttribute('height', height * fig.ratio);\n",
       "            }\n",
       "            canvas.setAttribute(\n",
       "                'style',\n",
       "                'width: ' + width + 'px; height: ' + height + 'px;'\n",
       "            );\n",
       "\n",
       "            rubberband_canvas.setAttribute('width', width);\n",
       "            rubberband_canvas.setAttribute('height', height);\n",
       "\n",
       "            // And update the size in Python. We ignore the initial 0/0 size\n",
       "            // that occurs as the element is placed into the DOM, which should\n",
       "            // otherwise not happen due to the minimum size styling.\n",
       "            if (fig.ws.readyState == 1 && width != 0 && height != 0) {\n",
       "                fig.request_resize(width, height);\n",
       "            }\n",
       "        }\n",
       "    });\n",
       "    this.resizeObserverInstance.observe(canvas_div);\n",
       "\n",
       "    function on_mouse_event_closure(name) {\n",
       "        return function (event) {\n",
       "            return fig.mouse_event(event, name);\n",
       "        };\n",
       "    }\n",
       "\n",
       "    rubberband_canvas.addEventListener(\n",
       "        'mousedown',\n",
       "        on_mouse_event_closure('button_press')\n",
       "    );\n",
       "    rubberband_canvas.addEventListener(\n",
       "        'mouseup',\n",
       "        on_mouse_event_closure('button_release')\n",
       "    );\n",
       "    rubberband_canvas.addEventListener(\n",
       "        'dblclick',\n",
       "        on_mouse_event_closure('dblclick')\n",
       "    );\n",
       "    // Throttle sequential mouse events to 1 every 20ms.\n",
       "    rubberband_canvas.addEventListener(\n",
       "        'mousemove',\n",
       "        on_mouse_event_closure('motion_notify')\n",
       "    );\n",
       "\n",
       "    rubberband_canvas.addEventListener(\n",
       "        'mouseenter',\n",
       "        on_mouse_event_closure('figure_enter')\n",
       "    );\n",
       "    rubberband_canvas.addEventListener(\n",
       "        'mouseleave',\n",
       "        on_mouse_event_closure('figure_leave')\n",
       "    );\n",
       "\n",
       "    canvas_div.addEventListener('wheel', function (event) {\n",
       "        if (event.deltaY < 0) {\n",
       "            event.step = 1;\n",
       "        } else {\n",
       "            event.step = -1;\n",
       "        }\n",
       "        on_mouse_event_closure('scroll')(event);\n",
       "    });\n",
       "\n",
       "    canvas_div.appendChild(canvas);\n",
       "    canvas_div.appendChild(rubberband_canvas);\n",
       "\n",
       "    this.rubberband_context = rubberband_canvas.getContext('2d');\n",
       "    this.rubberband_context.strokeStyle = '#000000';\n",
       "\n",
       "    this._resize_canvas = function (width, height, forward) {\n",
       "        if (forward) {\n",
       "            canvas_div.style.width = width + 'px';\n",
       "            canvas_div.style.height = height + 'px';\n",
       "        }\n",
       "    };\n",
       "\n",
       "    // Disable right mouse context menu.\n",
       "    this.rubberband_canvas.addEventListener('contextmenu', function (_e) {\n",
       "        event.preventDefault();\n",
       "        return false;\n",
       "    });\n",
       "\n",
       "    function set_focus() {\n",
       "        canvas.focus();\n",
       "        canvas_div.focus();\n",
       "    }\n",
       "\n",
       "    window.setTimeout(set_focus, 100);\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._init_toolbar = function () {\n",
       "    var fig = this;\n",
       "\n",
       "    var toolbar = document.createElement('div');\n",
       "    toolbar.classList = 'mpl-toolbar';\n",
       "    this.root.appendChild(toolbar);\n",
       "\n",
       "    function on_click_closure(name) {\n",
       "        return function (_event) {\n",
       "            return fig.toolbar_button_onclick(name);\n",
       "        };\n",
       "    }\n",
       "\n",
       "    function on_mouseover_closure(tooltip) {\n",
       "        return function (event) {\n",
       "            if (!event.currentTarget.disabled) {\n",
       "                return fig.toolbar_button_onmouseover(tooltip);\n",
       "            }\n",
       "        };\n",
       "    }\n",
       "\n",
       "    fig.buttons = {};\n",
       "    var buttonGroup = document.createElement('div');\n",
       "    buttonGroup.classList = 'mpl-button-group';\n",
       "    for (var toolbar_ind in mpl.toolbar_items) {\n",
       "        var name = mpl.toolbar_items[toolbar_ind][0];\n",
       "        var tooltip = mpl.toolbar_items[toolbar_ind][1];\n",
       "        var image = mpl.toolbar_items[toolbar_ind][2];\n",
       "        var method_name = mpl.toolbar_items[toolbar_ind][3];\n",
       "\n",
       "        if (!name) {\n",
       "            /* Instead of a spacer, we start a new button group. */\n",
       "            if (buttonGroup.hasChildNodes()) {\n",
       "                toolbar.appendChild(buttonGroup);\n",
       "            }\n",
       "            buttonGroup = document.createElement('div');\n",
       "            buttonGroup.classList = 'mpl-button-group';\n",
       "            continue;\n",
       "        }\n",
       "\n",
       "        var button = (fig.buttons[name] = document.createElement('button'));\n",
       "        button.classList = 'mpl-widget';\n",
       "        button.setAttribute('role', 'button');\n",
       "        button.setAttribute('aria-disabled', 'false');\n",
       "        button.addEventListener('click', on_click_closure(method_name));\n",
       "        button.addEventListener('mouseover', on_mouseover_closure(tooltip));\n",
       "\n",
       "        var icon_img = document.createElement('img');\n",
       "        icon_img.src = '_images/' + image + '.png';\n",
       "        icon_img.srcset = '_images/' + image + '_large.png 2x';\n",
       "        icon_img.alt = tooltip;\n",
       "        button.appendChild(icon_img);\n",
       "\n",
       "        buttonGroup.appendChild(button);\n",
       "    }\n",
       "\n",
       "    if (buttonGroup.hasChildNodes()) {\n",
       "        toolbar.appendChild(buttonGroup);\n",
       "    }\n",
       "\n",
       "    var fmt_picker = document.createElement('select');\n",
       "    fmt_picker.classList = 'mpl-widget';\n",
       "    toolbar.appendChild(fmt_picker);\n",
       "    this.format_dropdown = fmt_picker;\n",
       "\n",
       "    for (var ind in mpl.extensions) {\n",
       "        var fmt = mpl.extensions[ind];\n",
       "        var option = document.createElement('option');\n",
       "        option.selected = fmt === mpl.default_extension;\n",
       "        option.innerHTML = fmt;\n",
       "        fmt_picker.appendChild(option);\n",
       "    }\n",
       "\n",
       "    var status_bar = document.createElement('span');\n",
       "    status_bar.classList = 'mpl-message';\n",
       "    toolbar.appendChild(status_bar);\n",
       "    this.message = status_bar;\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {\n",
       "    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,\n",
       "    // which will in turn request a refresh of the image.\n",
       "    this.send_message('resize', { width: x_pixels, height: y_pixels });\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.send_message = function (type, properties) {\n",
       "    properties['type'] = type;\n",
       "    properties['figure_id'] = this.id;\n",
       "    this.ws.send(JSON.stringify(properties));\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.send_draw_message = function () {\n",
       "    if (!this.waiting) {\n",
       "        this.waiting = true;\n",
       "        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_save = function (fig, _msg) {\n",
       "    var format_dropdown = fig.format_dropdown;\n",
       "    var format = format_dropdown.options[format_dropdown.selectedIndex].value;\n",
       "    fig.ondownload(fig, format);\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_resize = function (fig, msg) {\n",
       "    var size = msg['size'];\n",
       "    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {\n",
       "        fig._resize_canvas(size[0], size[1], msg['forward']);\n",
       "        fig.send_message('refresh', {});\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_rubberband = function (fig, msg) {\n",
       "    var x0 = msg['x0'] / fig.ratio;\n",
       "    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;\n",
       "    var x1 = msg['x1'] / fig.ratio;\n",
       "    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;\n",
       "    x0 = Math.floor(x0) + 0.5;\n",
       "    y0 = Math.floor(y0) + 0.5;\n",
       "    x1 = Math.floor(x1) + 0.5;\n",
       "    y1 = Math.floor(y1) + 0.5;\n",
       "    var min_x = Math.min(x0, x1);\n",
       "    var min_y = Math.min(y0, y1);\n",
       "    var width = Math.abs(x1 - x0);\n",
       "    var height = Math.abs(y1 - y0);\n",
       "\n",
       "    fig.rubberband_context.clearRect(\n",
       "        0,\n",
       "        0,\n",
       "        fig.canvas.width / fig.ratio,\n",
       "        fig.canvas.height / fig.ratio\n",
       "    );\n",
       "\n",
       "    fig.rubberband_context.strokeRect(min_x, min_y, width, height);\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_figure_label = function (fig, msg) {\n",
       "    // Updates the figure title.\n",
       "    fig.header.textContent = msg['label'];\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_cursor = function (fig, msg) {\n",
       "    var cursor = msg['cursor'];\n",
       "    switch (cursor) {\n",
       "        case 0:\n",
       "            cursor = 'pointer';\n",
       "            break;\n",
       "        case 1:\n",
       "            cursor = 'default';\n",
       "            break;\n",
       "        case 2:\n",
       "            cursor = 'crosshair';\n",
       "            break;\n",
       "        case 3:\n",
       "            cursor = 'move';\n",
       "            break;\n",
       "    }\n",
       "    fig.rubberband_canvas.style.cursor = cursor;\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_message = function (fig, msg) {\n",
       "    fig.message.textContent = msg['message'];\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_draw = function (fig, _msg) {\n",
       "    // Request the server to send over a new figure.\n",
       "    fig.send_draw_message();\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_image_mode = function (fig, msg) {\n",
       "    fig.image_mode = msg['mode'];\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_history_buttons = function (fig, msg) {\n",
       "    for (var key in msg) {\n",
       "        if (!(key in fig.buttons)) {\n",
       "            continue;\n",
       "        }\n",
       "        fig.buttons[key].disabled = !msg[key];\n",
       "        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {\n",
       "    if (msg['mode'] === 'PAN') {\n",
       "        fig.buttons['Pan'].classList.add('active');\n",
       "        fig.buttons['Zoom'].classList.remove('active');\n",
       "    } else if (msg['mode'] === 'ZOOM') {\n",
       "        fig.buttons['Pan'].classList.remove('active');\n",
       "        fig.buttons['Zoom'].classList.add('active');\n",
       "    } else {\n",
       "        fig.buttons['Pan'].classList.remove('active');\n",
       "        fig.buttons['Zoom'].classList.remove('active');\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.updated_canvas_event = function () {\n",
       "    // Called whenever the canvas gets updated.\n",
       "    this.send_message('ack', {});\n",
       "};\n",
       "\n",
       "// A function to construct a web socket function for onmessage handling.\n",
       "// Called in the figure constructor.\n",
       "mpl.figure.prototype._make_on_message_function = function (fig) {\n",
       "    return function socket_on_message(evt) {\n",
       "        if (evt.data instanceof Blob) {\n",
       "            var img = evt.data;\n",
       "            if (img.type !== 'image/png') {\n",
       "                /* FIXME: We get \"Resource interpreted as Image but\n",
       "                 * transferred with MIME type text/plain:\" errors on\n",
       "                 * Chrome.  But how to set the MIME type?  It doesn't seem\n",
       "                 * to be part of the websocket stream */\n",
       "                img.type = 'image/png';\n",
       "            }\n",
       "\n",
       "            /* Free the memory for the previous frames */\n",
       "            if (fig.imageObj.src) {\n",
       "                (window.URL || window.webkitURL).revokeObjectURL(\n",
       "                    fig.imageObj.src\n",
       "                );\n",
       "            }\n",
       "\n",
       "            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(\n",
       "                img\n",
       "            );\n",
       "            fig.updated_canvas_event();\n",
       "            fig.waiting = false;\n",
       "            return;\n",
       "        } else if (\n",
       "            typeof evt.data === 'string' &&\n",
       "            evt.data.slice(0, 21) === 'data:image/png;base64'\n",
       "        ) {\n",
       "            fig.imageObj.src = evt.data;\n",
       "            fig.updated_canvas_event();\n",
       "            fig.waiting = false;\n",
       "            return;\n",
       "        }\n",
       "\n",
       "        var msg = JSON.parse(evt.data);\n",
       "        var msg_type = msg['type'];\n",
       "\n",
       "        // Call the  \"handle_{type}\" callback, which takes\n",
       "        // the figure and JSON message as its only arguments.\n",
       "        try {\n",
       "            var callback = fig['handle_' + msg_type];\n",
       "        } catch (e) {\n",
       "            console.log(\n",
       "                \"No handler for the '\" + msg_type + \"' message type: \",\n",
       "                msg\n",
       "            );\n",
       "            return;\n",
       "        }\n",
       "\n",
       "        if (callback) {\n",
       "            try {\n",
       "                // console.log(\"Handling '\" + msg_type + \"' message: \", msg);\n",
       "                callback(fig, msg);\n",
       "            } catch (e) {\n",
       "                console.log(\n",
       "                    \"Exception inside the 'handler_\" + msg_type + \"' callback:\",\n",
       "                    e,\n",
       "                    e.stack,\n",
       "                    msg\n",
       "                );\n",
       "            }\n",
       "        }\n",
       "    };\n",
       "};\n",
       "\n",
       "// from http://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas\n",
       "mpl.findpos = function (e) {\n",
       "    //this section is from http://www.quirksmode.org/js/events_properties.html\n",
       "    var targ;\n",
       "    if (!e) {\n",
       "        e = window.event;\n",
       "    }\n",
       "    if (e.target) {\n",
       "        targ = e.target;\n",
       "    } else if (e.srcElement) {\n",
       "        targ = e.srcElement;\n",
       "    }\n",
       "    if (targ.nodeType === 3) {\n",
       "        // defeat Safari bug\n",
       "        targ = targ.parentNode;\n",
       "    }\n",
       "\n",
       "    // pageX,Y are the mouse positions relative to the document\n",
       "    var boundingRect = targ.getBoundingClientRect();\n",
       "    var x = e.pageX - (boundingRect.left + document.body.scrollLeft);\n",
       "    var y = e.pageY - (boundingRect.top + document.body.scrollTop);\n",
       "\n",
       "    return { x: x, y: y };\n",
       "};\n",
       "\n",
       "/*\n",
       " * return a copy of an object with only non-object keys\n",
       " * we need this to avoid circular references\n",
       " * http://stackoverflow.com/a/24161582/3208463\n",
       " */\n",
       "function simpleKeys(original) {\n",
       "    return Object.keys(original).reduce(function (obj, key) {\n",
       "        if (typeof original[key] !== 'object') {\n",
       "            obj[key] = original[key];\n",
       "        }\n",
       "        return obj;\n",
       "    }, {});\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.mouse_event = function (event, name) {\n",
       "    var canvas_pos = mpl.findpos(event);\n",
       "\n",
       "    if (name === 'button_press') {\n",
       "        this.canvas.focus();\n",
       "        this.canvas_div.focus();\n",
       "    }\n",
       "\n",
       "    var x = canvas_pos.x * this.ratio;\n",
       "    var y = canvas_pos.y * this.ratio;\n",
       "\n",
       "    this.send_message(name, {\n",
       "        x: x,\n",
       "        y: y,\n",
       "        button: event.button,\n",
       "        step: event.step,\n",
       "        guiEvent: simpleKeys(event),\n",
       "    });\n",
       "\n",
       "    /* This prevents the web browser from automatically changing to\n",
       "     * the text insertion cursor when the button is pressed.  We want\n",
       "     * to control all of the cursor setting manually through the\n",
       "     * 'cursor' event from matplotlib */\n",
       "    event.preventDefault();\n",
       "    return false;\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._key_event_extra = function (_event, _name) {\n",
       "    // Handle any extra behaviour associated with a key event\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.key_event = function (event, name) {\n",
       "    // Prevent repeat events\n",
       "    if (name === 'key_press') {\n",
       "        if (event.key === this._key) {\n",
       "            return;\n",
       "        } else {\n",
       "            this._key = event.key;\n",
       "        }\n",
       "    }\n",
       "    if (name === 'key_release') {\n",
       "        this._key = null;\n",
       "    }\n",
       "\n",
       "    var value = '';\n",
       "    if (event.ctrlKey && event.key !== 'Control') {\n",
       "        value += 'ctrl+';\n",
       "    }\n",
       "    else if (event.altKey && event.key !== 'Alt') {\n",
       "        value += 'alt+';\n",
       "    }\n",
       "    else if (event.shiftKey && event.key !== 'Shift') {\n",
       "        value += 'shift+';\n",
       "    }\n",
       "\n",
       "    value += 'k' + event.key;\n",
       "\n",
       "    this._key_event_extra(event, name);\n",
       "\n",
       "    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });\n",
       "    return false;\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.toolbar_button_onclick = function (name) {\n",
       "    if (name === 'download') {\n",
       "        this.handle_save(this, null);\n",
       "    } else {\n",
       "        this.send_message('toolbar_button', { name: name });\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {\n",
       "    this.message.textContent = tooltip;\n",
       "};\n",
       "\n",
       "///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////\n",
       "// prettier-ignore\n",
       "var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError(\"Constructor requires 'new' operator\");i.set(this,e)}function h(){throw new TypeError(\"Function is not a constructor\")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line\n",
       "mpl.toolbar_items = [[\"Home\", \"Reset original view\", \"fa fa-home icon-home\", \"home\"], [\"Back\", \"Back to previous view\", \"fa fa-arrow-left icon-arrow-left\", \"back\"], [\"Forward\", \"Forward to next view\", \"fa fa-arrow-right icon-arrow-right\", \"forward\"], [\"\", \"\", \"\", \"\"], [\"Pan\", \"Left button pans, Right button zooms\\nx/y fixes axis, CTRL fixes aspect\", \"fa fa-arrows icon-move\", \"pan\"], [\"Zoom\", \"Zoom to rectangle\\nx/y fixes axis, CTRL fixes aspect\", \"fa fa-square-o icon-check-empty\", \"zoom\"], [\"\", \"\", \"\", \"\"], [\"Download\", \"Download plot\", \"fa fa-floppy-o icon-save\", \"download\"]];\n",
       "\n",
       "mpl.extensions = [\"eps\", \"jpeg\", \"pgf\", \"pdf\", \"png\", \"ps\", \"raw\", \"svg\", \"tif\"];\n",
       "\n",
       "mpl.default_extension = \"png\";/* global mpl */\n",
       "\n",
       "var comm_websocket_adapter = function (comm) {\n",
       "    // Create a \"websocket\"-like object which calls the given IPython comm\n",
       "    // object with the appropriate methods. Currently this is a non binary\n",
       "    // socket, so there is still some room for performance tuning.\n",
       "    var ws = {};\n",
       "\n",
       "    ws.binaryType = comm.kernel.ws.binaryType;\n",
       "    ws.readyState = comm.kernel.ws.readyState;\n",
       "    function updateReadyState(_event) {\n",
       "        if (comm.kernel.ws) {\n",
       "            ws.readyState = comm.kernel.ws.readyState;\n",
       "        } else {\n",
       "            ws.readyState = 3; // Closed state.\n",
       "        }\n",
       "    }\n",
       "    comm.kernel.ws.addEventListener('open', updateReadyState);\n",
       "    comm.kernel.ws.addEventListener('close', updateReadyState);\n",
       "    comm.kernel.ws.addEventListener('error', updateReadyState);\n",
       "\n",
       "    ws.close = function () {\n",
       "        comm.close();\n",
       "    };\n",
       "    ws.send = function (m) {\n",
       "        //console.log('sending', m);\n",
       "        comm.send(m);\n",
       "    };\n",
       "    // Register the callback with on_msg.\n",
       "    comm.on_msg(function (msg) {\n",
       "        //console.log('receiving', msg['content']['data'], msg);\n",
       "        var data = msg['content']['data'];\n",
       "        if (data['blob'] !== undefined) {\n",
       "            data = {\n",
       "                data: new Blob(msg['buffers'], { type: data['blob'] }),\n",
       "            };\n",
       "        }\n",
       "        // Pass the mpl event to the overridden (by mpl) onmessage function.\n",
       "        ws.onmessage(data);\n",
       "    });\n",
       "    return ws;\n",
       "};\n",
       "\n",
       "mpl.mpl_figure_comm = function (comm, msg) {\n",
       "    // This is the function which gets called when the mpl process\n",
       "    // starts-up an IPython Comm through the \"matplotlib\" channel.\n",
       "\n",
       "    var id = msg.content.data.id;\n",
       "    // Get hold of the div created by the display call when the Comm\n",
       "    // socket was opened in Python.\n",
       "    var element = document.getElementById(id);\n",
       "    var ws_proxy = comm_websocket_adapter(comm);\n",
       "\n",
       "    function ondownload(figure, _format) {\n",
       "        window.open(figure.canvas.toDataURL());\n",
       "    }\n",
       "\n",
       "    var fig = new mpl.figure(id, ws_proxy, ondownload, element);\n",
       "\n",
       "    // Call onopen now - mpl needs it, as it is assuming we've passed it a real\n",
       "    // web socket which is closed, not our websocket->open comm proxy.\n",
       "    ws_proxy.onopen();\n",
       "\n",
       "    fig.parent_element = element;\n",
       "    fig.cell_info = mpl.find_output_cell(\"<div id='\" + id + \"'></div>\");\n",
       "    if (!fig.cell_info) {\n",
       "        console.error('Failed to find cell for figure', id, fig);\n",
       "        return;\n",
       "    }\n",
       "    fig.cell_info[0].output_area.element.on(\n",
       "        'cleared',\n",
       "        { fig: fig },\n",
       "        fig._remove_fig_handler\n",
       "    );\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_close = function (fig, msg) {\n",
       "    var width = fig.canvas.width / fig.ratio;\n",
       "    fig.cell_info[0].output_area.element.off(\n",
       "        'cleared',\n",
       "        fig._remove_fig_handler\n",
       "    );\n",
       "    fig.resizeObserverInstance.unobserve(fig.canvas_div);\n",
       "\n",
       "    // Update the output cell to use the data from the current canvas.\n",
       "    fig.push_to_output();\n",
       "    var dataURL = fig.canvas.toDataURL();\n",
       "    // Re-enable the keyboard manager in IPython - without this line, in FF,\n",
       "    // the notebook keyboard shortcuts fail.\n",
       "    IPython.keyboard_manager.enable();\n",
       "    fig.parent_element.innerHTML =\n",
       "        '<img src=\"' + dataURL + '\" width=\"' + width + '\">';\n",
       "    fig.close_ws(fig, msg);\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.close_ws = function (fig, msg) {\n",
       "    fig.send_message('closing', msg);\n",
       "    // fig.ws.close()\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.push_to_output = function (_remove_interactive) {\n",
       "    // Turn the data on the canvas into data in the output cell.\n",
       "    var width = this.canvas.width / this.ratio;\n",
       "    var dataURL = this.canvas.toDataURL();\n",
       "    this.cell_info[1]['text/html'] =\n",
       "        '<img src=\"' + dataURL + '\" width=\"' + width + '\">';\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.updated_canvas_event = function () {\n",
       "    // Tell IPython that the notebook contents must change.\n",
       "    IPython.notebook.set_dirty(true);\n",
       "    this.send_message('ack', {});\n",
       "    var fig = this;\n",
       "    // Wait a second, then push the new image to the DOM so\n",
       "    // that it is saved nicely (might be nice to debounce this).\n",
       "    setTimeout(function () {\n",
       "        fig.push_to_output();\n",
       "    }, 1000);\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._init_toolbar = function () {\n",
       "    var fig = this;\n",
       "\n",
       "    var toolbar = document.createElement('div');\n",
       "    toolbar.classList = 'btn-toolbar';\n",
       "    this.root.appendChild(toolbar);\n",
       "\n",
       "    function on_click_closure(name) {\n",
       "        return function (_event) {\n",
       "            return fig.toolbar_button_onclick(name);\n",
       "        };\n",
       "    }\n",
       "\n",
       "    function on_mouseover_closure(tooltip) {\n",
       "        return function (event) {\n",
       "            if (!event.currentTarget.disabled) {\n",
       "                return fig.toolbar_button_onmouseover(tooltip);\n",
       "            }\n",
       "        };\n",
       "    }\n",
       "\n",
       "    fig.buttons = {};\n",
       "    var buttonGroup = document.createElement('div');\n",
       "    buttonGroup.classList = 'btn-group';\n",
       "    var button;\n",
       "    for (var toolbar_ind in mpl.toolbar_items) {\n",
       "        var name = mpl.toolbar_items[toolbar_ind][0];\n",
       "        var tooltip = mpl.toolbar_items[toolbar_ind][1];\n",
       "        var image = mpl.toolbar_items[toolbar_ind][2];\n",
       "        var method_name = mpl.toolbar_items[toolbar_ind][3];\n",
       "\n",
       "        if (!name) {\n",
       "            /* Instead of a spacer, we start a new button group. */\n",
       "            if (buttonGroup.hasChildNodes()) {\n",
       "                toolbar.appendChild(buttonGroup);\n",
       "            }\n",
       "            buttonGroup = document.createElement('div');\n",
       "            buttonGroup.classList = 'btn-group';\n",
       "            continue;\n",
       "        }\n",
       "\n",
       "        button = fig.buttons[name] = document.createElement('button');\n",
       "        button.classList = 'btn btn-default';\n",
       "        button.href = '#';\n",
       "        button.title = name;\n",
       "        button.innerHTML = '<i class=\"fa ' + image + ' fa-lg\"></i>';\n",
       "        button.addEventListener('click', on_click_closure(method_name));\n",
       "        button.addEventListener('mouseover', on_mouseover_closure(tooltip));\n",
       "        buttonGroup.appendChild(button);\n",
       "    }\n",
       "\n",
       "    if (buttonGroup.hasChildNodes()) {\n",
       "        toolbar.appendChild(buttonGroup);\n",
       "    }\n",
       "\n",
       "    // Add the status bar.\n",
       "    var status_bar = document.createElement('span');\n",
       "    status_bar.classList = 'mpl-message pull-right';\n",
       "    toolbar.appendChild(status_bar);\n",
       "    this.message = status_bar;\n",
       "\n",
       "    // Add the close button to the window.\n",
       "    var buttongrp = document.createElement('div');\n",
       "    buttongrp.classList = 'btn-group inline pull-right';\n",
       "    button = document.createElement('button');\n",
       "    button.classList = 'btn btn-mini btn-primary';\n",
       "    button.href = '#';\n",
       "    button.title = 'Stop Interaction';\n",
       "    button.innerHTML = '<i class=\"fa fa-power-off icon-remove icon-large\"></i>';\n",
       "    button.addEventListener('click', function (_evt) {\n",
       "        fig.handle_close(fig, {});\n",
       "    });\n",
       "    button.addEventListener(\n",
       "        'mouseover',\n",
       "        on_mouseover_closure('Stop Interaction')\n",
       "    );\n",
       "    buttongrp.appendChild(button);\n",
       "    var titlebar = this.root.querySelector('.ui-dialog-titlebar');\n",
       "    titlebar.insertBefore(buttongrp, titlebar.firstChild);\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._remove_fig_handler = function (event) {\n",
       "    var fig = event.data.fig;\n",
       "    if (event.target !== this) {\n",
       "        // Ignore bubbled events from children.\n",
       "        return;\n",
       "    }\n",
       "    fig.close_ws(fig, {});\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._root_extra_style = function (el) {\n",
       "    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._canvas_extra_style = function (el) {\n",
       "    // this is important to make the div 'focusable\n",
       "    el.setAttribute('tabindex', 0);\n",
       "    // reach out to IPython and tell the keyboard manager to turn it's self\n",
       "    // off when our div gets focus\n",
       "\n",
       "    // location in version 3\n",
       "    if (IPython.notebook.keyboard_manager) {\n",
       "        IPython.notebook.keyboard_manager.register_events(el);\n",
       "    } else {\n",
       "        // location in version 2\n",
       "        IPython.keyboard_manager.register_events(el);\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype._key_event_extra = function (event, _name) {\n",
       "    var manager = IPython.notebook.keyboard_manager;\n",
       "    if (!manager) {\n",
       "        manager = IPython.keyboard_manager;\n",
       "    }\n",
       "\n",
       "    // Check for shift+enter\n",
       "    if (event.shiftKey && event.which === 13) {\n",
       "        this.canvas_div.blur();\n",
       "        // select the cell after this one\n",
       "        var index = IPython.notebook.find_cell_index(this.cell_info[0]);\n",
       "        IPython.notebook.select(index + 1);\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_save = function (fig, _msg) {\n",
       "    fig.ondownload(fig, null);\n",
       "};\n",
       "\n",
       "mpl.find_output_cell = function (html_output) {\n",
       "    // Return the cell and output element which can be found *uniquely* in the notebook.\n",
       "    // Note - this is a bit hacky, but it is done because the \"notebook_saving.Notebook\"\n",
       "    // IPython event is triggered only after the cells have been serialised, which for\n",
       "    // our purposes (turning an active figure into a static one), is too late.\n",
       "    var cells = IPython.notebook.get_cells();\n",
       "    var ncells = cells.length;\n",
       "    for (var i = 0; i < ncells; i++) {\n",
       "        var cell = cells[i];\n",
       "        if (cell.cell_type === 'code') {\n",
       "            for (var j = 0; j < cell.output_area.outputs.length; j++) {\n",
       "                var data = cell.output_area.outputs[j];\n",
       "                if (data.data) {\n",
       "                    // IPython >= 3 moved mimebundle to data attribute of output\n",
       "                    data = data.data;\n",
       "                }\n",
       "                if (data['text/html'] === html_output) {\n",
       "                    return [cell, data, j];\n",
       "                }\n",
       "            }\n",
       "        }\n",
       "    }\n",
       "};\n",
       "\n",
       "// Register the function which deals with the matplotlib target/channel.\n",
       "// The kernel may be null if the page has been refreshed.\n",
       "if (IPython.notebook.kernel !== null) {\n",
       "    IPython.notebook.kernel.comm_manager.register_target(\n",
       "        'matplotlib',\n",
       "        mpl.mpl_figure_comm\n",
       "    );\n",
       "}\n"
      ],
      "text/plain": [
       "<IPython.core.display.Javascript object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<img src=\"data:image/png;base64,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\" width=\"640\">"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Indicamos al Notebook que queremos figuras interactivas (esto sólo es necesario hacerlo una vez)\n",
    "%matplotlib notebook\n",
    "\n",
    "import matplotlib.pyplot as plt  # Importamos la librería (esto sólo es necesario hacerlo una vez)\n",
    "import math\n",
    "\n",
    "# definimos algunas líneas de tendencia arbitrarias\n",
    "vectorx = [x for x in range (1,10)]\n",
    "vectorlogy = [ math.log(i) for i in vectorx ]\n",
    "vectorpowy = [ math.pow(i, 2) for i in vectorx ]\n",
    "\n",
    "fig = plt.figure()  # Creamos una figura (contenedor para elementos a dibujar)\n",
    "ax = fig.add_subplot(111, projection='rectilinear')  # añadimos subplot-canvas a la figura (contiene los elementos del dibujo)\n",
    " \n",
    "# añadimos los plots\n",
    "ax.plot(vectorx, vectorlogy, '--', color=\"green\")\n",
    "ax.plot(vectorx, vectorpowy, '--', color=\"red\")\n",
    " \n",
    "ax.set_title(\"Ejemplo\")  # Ponemos un título\n",
    "ax.set_xlabel(\"Eje X\")  # Nombramos los ejes\n",
    "ax.set_ylabel(\"Eje Y\")\n",
    " \n",
    "plt.show()  # Mostramos a figura por pantalla, que se corresponde con la fig creada arriba"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f73d01d4",
   "metadata": {
    "tags": []
   },
   "source": [
    "---\n",
    "\n",
    "# El Problema del Viajante de Comercio (VC) con Búsqueda Tabú\n",
    "\n",
    "De nuevo, trataremos de resolver el problema del Viajante de Comercio, pero ahora con el algoritmo de Búsqueda Tabú.\n",
    "\n",
    "El objetivo de esta práctica es modelar e implementar un agente inteligente que sea capaz de resolver el problema del VC mediante la metaheurística (MH) de Busquedá Tabú (TS, del inglés Tabu Search). Para ello, realizarás una implementación del algoritmo básico visto en la clase expositiva y valorarás si la introducción de modificaciones en el diseño del algoritmo te permite mejorar la calidad de las soluciones alcanzadas."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8d0f75f2",
   "metadata": {},
   "source": [
    "\n",
    "## Definición del problema de Viajante de Comercio (VC)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2d8f430b",
   "metadata": {},
   "source": [
    "\n",
    "El problema del viajante de comercio (VC) es el problema de la persona que quiere vender un producto, y que para ello quiere encontrar el viaje más corto posible a través de las ciudades de los clientes, haciendo una única visita a cada una, empezando y acabando el recorrido en su propia ciudad (recorrido circular desde la ciudad inicial).\n",
    "Típicamente, el problema parte de una representación mediante un grafo ponderado $G=(N, A)$, donde $N$ es el conjunto de $n=|N|$ nodos (ciudades), y siendo A el conjunto de arcos conectando los nodos. Cada arco $(i, j) ∈ A$ tiene asignado un peso $d_ij$ que representa la distancia entre las ciudades $i$ y $j$.\n",
    "El VC se reduce al problema de crear el circuito Hamiltoniano de longitud mínima sobre el grafo $G$. La solución a una instancia del problema del VC puede representarse como una permutación de los índices de las ciudades, donde lo importante es el orden de visita, que determinará el coste del viaje en términos de la distancia recorrida total. \n",
    "De este modo, el problema pertenece a la categoría de problemas NP, pues puede haber n permutaciones que se corresponden al espacio de búsqueda posible. Esto hace que resolver instancias de problemas con muchas ciudades (n grande) haga el problema impracticable con estrategias de búsqueda no-informadas y éste pueda beneficiarse de ciertas metaheurísticas, pudiendo abordar de problemas con tallas más grande a la vez que se obtienen soluciones razonablemente buenas.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a2d6367",
   "metadata": {},
   "source": [
    "### Nociones previas\n",
    "\n",
    "Para facilitar vuestra labor de implementación, os proporcionamos la clase `Localizaciones`, que permite cargar las localizaciones GPS que representan los vértices del grafo G de N ciudades, y permite calcular de manera transparente la distancia entre cualquier par de ciudades usando la [fórmula del semiverseno]( https://es.wikipedia.org/wiki/F%C3%B3rmula_del_semiverseno), que sirve para calcular las distancias teniendo en cuenta la curvatura de la Tierra. \n",
    "Es importante tener en cuenta que en la fórmula del semiverseno las coordenadas se expresan en radianes.\n",
    "\n",
    "\n",
    "En primer lugar importa el módulo Python que acompaña esta práctica, que trae alguna función de apoyo implementada así como la clase de carga de datos."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "7e422090",
   "metadata": {},
   "outputs": [],
   "source": [
    "from helpers_mod_sa import *"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6438416b",
   "metadata": {},
   "source": [
    "Inspecciona el código de carga de localizaciones mediante `psource(Localizaciones)`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b4b9896c",
   "metadata": {},
   "outputs": [],
   "source": [
    "psource (Localizaciones)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "87ee11d6",
   "metadata": {},
   "source": [
    "Fíjate que por defecto se carga el fichero `./data/grafo8cidades.txt`, que contiene las coordenadas GPS de 8 ciudades gallegas, siendo Santiago de Compostela la primera de ellas. La primera línea de estos ficheros indica el número de ciudades n, mientras que cada una de las líneas sucesivas especifican las coordenadas de cada ciudad, especificadas como coordenadas GPS (latitud y longitud en grados).\n",
    "\n",
    "Puedes cargar otro fichero haciendo uso del parámetro `filename` como se muestra a continuación. Si todo va bien, la primera distancia entre la ciudad 0 y 1 debe ser unos 55 km.\n",
    "\n",
    "❗ Para esta práctica, **debéis utilizar** el fichero `./data/grafo100cidades.txt` que contiene las coordenadas de 100 concellos gallegos."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "12ff980c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "55.88273580792048\n",
      "119.30959564041359\n",
      "68.81748609463234\n"
     ]
    }
   ],
   "source": [
    "g1=Localizaciones(filename='./data/grafo8cidades.txt')\n",
    "print (g1.distancia(0,1))\n",
    "g2=Localizaciones(filename='./data/grafos10_10/grafo_1.txt')\n",
    "print (g2.distancia(0,1))\n",
    "g3=Localizaciones(filename='./data/grafo100cidades.txt')\n",
    "print(g3.distancia(0,1))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "045122c3",
   "metadata": {},
   "source": [
    "\n",
    "## P2.1: Implementación básica de Búsqueda Tabú (especificación obligatoria, 6pts)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "88a4e0a6",
   "metadata": {
    "tags": []
   },
   "source": [
    "\n",
    "En este apartado debes desarrollar una **versión básica del algoritmo de Búsqueda Tabú que resuelva el problema del viajante de comercio (TSP)** aplicado a los concellos de Galicia. La especificación del algoritmo será muy detallada, ya que el objetivo principal de esta primera parte es que dispongas de una implementación totalmente funcional y verificada que resuelva el problema correctamente.\n",
    "Igual que en la práctica anterior (P1), consideramos que el recorrido es circular (empieza y termina en el mismo concello) y que tienen que pasar por N=100 concellos de Galicia. Implementa el algoritmo básico de Búsqueda Tabú para resolver el problema del VC enunciado arriba. Para ello, revisa la descripción algorítmica de la MH vista en la clase expositiva.\n",
    "\n",
    "Ten en cuenta las **siguientes consideraciones** de diseño para completar la implementación básica:\n",
    "- **Representación  de  las  soluciones:**  representación  de  orden  (permutaciones)  **comenzando y finalizando en la ciudad 0**. Es decir, utilizamos una representación de orden formada por una secuencia de valores numéricos que representan cada uno de los concellos {0, 1, ..., 99}. Consideramos siempre como punto de partida y retorno el concello 0, por lo que efectivamente una solución *S* se representa como una permutación de los demás valores {1, ..., 99}. \n",
    "\n",
    "\n",
    "- **Solución inicial:** generación **totalmente aleatoria** de una permutación válida como está explicado en los apartados previos. \n",
    "\n",
    "❗  **NOTA: Es importante que la generación de la solución inicial se implemente en una función propia y que después, esta solución inicial se pase a la función que implementa el algoritmo de búsqueda tabú *per se*.**\n",
    "\n",
    "\n",
    "- **Operador  de  generación de vecindario de una solución** (generación de la solución  siguiente  $S_{cand}$  a  partir  de  la  actual  $S_{act}$): Se utilizará el **operador  de  intercambio** y se generarán *todos los posibles intercambios**. Es decir, con este operador, se explota el vecindario de forma completa, con lo que se genera el siguiente número de vecinos:\n",
    "\n",
    "$$ \\sum_{i=1}^{L-1}i = \\frac{L(L-1)}{2} $$\n",
    "\n",
    "donde *L* es la longitud de la solución y se ha tenido en cuenta que es lo mismo intercambiar los vecinos *i, j* que *j, i*.\n",
    "\n",
    "❗  **NOTA: Es importante que la generación del vecindario de una solución se implemente en una función propia y que después, el vecino seleccionado, se pase a la función que implementa el algoritmo de búsqueda tabú *per se*.**\n",
    "\n",
    "\n",
    "\n",
    "- **Función de coste:** suma de las distancias del camino según el orden del recorrido teniendo en cuenta que se parte de y se llega al concello 0.  La distancia se calcula teniendo en cuenta los siguientes tres elementos:\n",
    "    - Distancia desde el concello 0 al primer concello de la solución: 0 -> S[0]\n",
    "    - Distancia recorrida en la solución: S[0] -> S[1] -> ... -> S[-1]\n",
    "    - Distancia recorrida desde el concello final al concello 0: S[-1] ->0\n",
    "    \n",
    "\n",
    "\n",
    "- **Lista Tabú:** La lista tabú (LT) estará formada por los **movimientos de intercambio de índices** {i,j} que den lugar a las soluciones que forman la trayectoria de búsqueda. Tenéis que establecer **N=100** como parámetro de tenencia tabú, esto es, el tamaño de la lista tabú será de **N** elementos, de forma que un movimiento {i,j} saldrá de la lista tabú después de **N=100** operaciones y volverá a estar permitido.\n",
    "\n",
    "\n",
    "- **Reinicialización:** En el caso de que transcurran **1000 iteraciones consecutivas** sin que mejore la solución óptima $S_{opt}$ alcanzada hasta el momento, se hará una reinicialización desde ella: $S_{opt}$. Se trata por tanto de una estrategia de reinicialización por **intensificación**. En el reinicio **no se restaura la lista tabú**, para dar opción a visitar vecinos no visitados anteriormente ya que determinados intercambios prohibidos al estar incluidos en la lista tabú. Es decir, cuando se hace un reinicio, se vuelve a la solución $S_{opt}$ y **se vacía la lista tabú.**\n",
    "\n",
    "\n",
    "- **Criterio de parada:** Se finaliza la ejecución cuando se alcanzan **10.000 iteraciones** del algoritmo.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a981c2f1",
   "metadata": {},
   "source": [
    "### Preguntas sobre la especificación básica obligatoria (se responde al final del notebook)\n",
    "\n",
    "❓ **Pregunta 1**. Explica brevemente los detalles relevantes de tu código para entender tu implementación (p.ej., estructura de tu código, funciones, etc.)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d2ae5035",
   "metadata": {},
   "source": [
    "❓ **Pregunta 2**. La parte experimental de la práctica consiste en realizar **10 ejecuciones diferentes** de la implementación realizada y reportar:\n",
    "- **Media y desviación** estándar de la mejor solución obtenida.\n",
    "- El **número de iteración** en el que se obtuvo la mejor solución (por lo que debéis mantener además de la solución óptima hasta el momento $S_{opt}$, la iteración en la que se obtiene). \n",
    "- El **tiempo de ejecución** del algoritmo (en las nociones previas se explica cómo hacer esto)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f9c05313",
   "metadata": {},
   "source": [
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ac8d9805",
   "metadata": {},
   "source": [
    " \n",
    "## P2.2: Mejoras del algoritmo de Búsqueda Tabú (especificación opcional, 4pts)\n",
    "En este apartado el objetivo es aplicar la resolución del problema que acabáis de programar a un nuevo conjunto de 120 localizaciones tomadas del archivo de [50.000 lugares históricos del Registro Nacional de los EE.UU](http://www.math.uwaterloo.ca/tsp/us/data.html), tal y como se describe en la web del [Traveller Salesman Problem (TSP)](http://www.math.uwaterloo.ca/tsp/) del [Department of Combinatorics and Optimization](https://uwaterloo.ca/combinatorics-and-optimization/) de la University of Waterloo CA [(Prof. William Cook)](http://www.math.uwaterloo.ca/~bico/).\n",
    "Para evitar problemas de tiempo excesivo de cómputo, reduciremos el problema a 120 localizaciones que se indican en el fichero **US120.txt**.\n",
    "\n",
    "**NOTA:** Si alguno de vosotros quiere realizar pruebas con todos los lugares indicados, puede obtener el fichero de texto original en el [siguiente enlace](http://www.math.uwaterloo.ca/tsp/us/files/us50000_latlong.txt).\n",
    "\n",
    "\n",
    "En esta sección el objetivo es realizar mejoras al algoritmo desarrollado previamente, de acuerdo a lo visto en las clases expositivas. Podrá modificarse cualquier parámetro u operador, como por ejemplo:\n",
    "- **Generación de la solución inicial** (inicialización greedy, ...)\n",
    "- **Gestión de la lista tabú** con la inclusión de algún criterio de aspiración (por ejemplo excluir de la lista una solución si mejora a la mejor solución hasta el momento)\n",
    "- El **operador de generación de vecinos** (por ejemplo no considerar todos los pares de índices, cambiar el operador de generación, ...)\n",
    "- Utilizar **otras estrategias de reinicialización** por intensificación (por ejemplo reiniciar desde una solución aleatoria de un conjunto de las N mejores soluciones hasta ahora, restaurar la lista tabú, ...).\n",
    "- Cambiar la **estrategia de reinicialización para dar diversificación** con una estrategia de **memoria a largo plazo**. Como puede ser utilizar una matriz simétriza *frec* que almacene elnúmero de veces que cada par de ciudades han sido consecutivas en las soluciones aceptadas hasta el momento. Con esta matriz de frecuencias se podría realizar una inicialización voraz sobre una matriz de distancias modificada que incluya las frecuencias almacenadas en memoria y penalice los pares de ciudads con mayor frecuencia, incrementando ficticiamente su distancia:\n",
    "\n",
    "$$ D(i,j)_{MOD} = D(i,j) + \\mu (D_{MAX} - D_{min}) \\frac{frec(i,j)}{frec_{MAX}} $$\n",
    "\n",
    "- Utilizar un criterio de **oscilación estratégica** que alterne entre las estrategias de intensificación y diversificación**-"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0c0ccfd8",
   "metadata": {},
   "source": [
    "### Preguntas sobre la práctica optativa con las mejoras (se responde al final del notebook)\n",
    "\n",
    "❓ **Pregunta 3**. ¿Qué intervenciones de mejora te ha llevado a mejores resultados? Explica brevemente las mejoras o intervenciones de mejora realizadas, cómo la has implementado, porqué las consideras buenas para el problema y presenta tus conclusiones acompañadas de los resultados obtenidos.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "82f11936",
   "metadata": {},
   "source": [
    "---\n",
    "\n",
    "# Respuestas a las preguntas y evaluación\n",
    "\n",
    "**Recordatorio:** No olvides escribir tu nombre y apellidos en la segunda celda de este documento.\n",
    "La respuestas a las preguntas deben venir acompañadas de las implementaciones necesarias para su respuesta.\n",
    "\n",
    "## P2.1 Especificación obligatoria (6pt)\n",
    "\n",
    "La implementación básica se evaluará mediante un cuestionario automático de evaluación. Es también necesaria **realizar la implementación del algoritmo** y **responder a las preguntas 1 y 2** respectivamente. El cuestionario de evaluación lo realizarás en la primera sesión de la próxima práctica, y se centrará en la resolución por tu parte de diversas cuestiones prácticas relacionadas con la implementación realizada, pudiendo ser necesaria la ejecución, adaptación y modificación de la misma.\n",
    "\n",
    "Aclaración: Independientemente del cuestionario automático de evaluación, siempre considera que las preguntas planteadas en el notebook deben ser respondidas también. Esas preguntas generales están diseñadas para formarte, y te servián para razonar y reflexionar sobre el tema, así como también para fomentar una discusión constructiva con los docentes en caso de dudas.\n",
    "\n",
    "\n",
    "### **Pregunta 1** \n",
    "\n",
    "Explica brevemente los detalles relevantes de tu código para entender tu implementación (p.ej., estructura de tu código, funciones, etc.)\n",
    "\n",
    "*Incluye todas las celdas que consideres oportunas para que sea legible y fácil de seguir.*\n",
    "\n",
    "<div class=\"alert alert-block alert-danger\">\n",
    "    <b>NOTA:</b> ¿Cómo me aseguro de que mi implementación es correcta?\n",
    "    \n",
    "Es importante que para poder comprobar la correcta implementación de tu solución, tu código tenga en cuenta los siguientes elementos:\n",
    "-  Mantener en cada iteración la mejor solución encontrada hasta el momento y la iteración en la que se encontró\n",
    "-  Que puedas imprimir los elementos que se encuentran en la lista tabú\n",
    "-  Saber en qué iteraciones se llevaron a cabo los reinicios\n",
    "</div>\n",
    "\n",
    "<div class=\"alert alert-block alert-success\">\n",
    "<b>NOTA:</b>  Para verificar tu implementación, debes utilizar el fichero de localizaciones de los 100 concellos gallegos (grafo100cidades.txt). Puedes utilizar como prueba para verificar que la implementaición es correcta inicialmente, el fichero de localizaciones de 8 ciudades gallegas (grafo8cidades.txt). La solución óptima resuelta con una búsqueda informada como A* se situa en torno a los 382km para el problema de prueba con 8 ciudades.\n",
    "</div>\n",
    "    \n",
    "<div class=\"alert alert-block alert-success\">    \n",
    "<b>AYUDA EXTRA</b>: Si quieres comprobar la implementación de tu práctica puedes probar a utilizar como solución inicial la solución siguiente (pasándosela directamente a la función que implementa el algoritmo de búsqueda tabú):\n",
    "    \n",
    "<b> Solución inicial: </b> \n",
    "- [77, 9, 43, 73, 2, 53, 12, 83, 92, 33, 50, 63, 54, 59, 64, 74, 55, 14, 35, 5, 58, 87, 37, 7, 69, 79, 89, 21, 23, 80, 20, 56, 75, 68, 27, 95, 78, 25, 88, 51, 47, 91, 49, 60, 13, 36, 70, 42, 11, 22, 40, 72, 28, 97, 19, 71, 29, 90, 85, 76, 16, 24, 81, 84, 34, 8, 31, 38, 67, 45, 44, 32, 96, 10, 61, 94, 17, 18, 93, 30, 52, 66, 99, 26, 46, 39, 15, 86, 41, 4, 62, 1, 48, 82, 57, 98, 3, 65, 6]\n",
    "\n",
    "Como resultados, deberías obtener los siguientes:\n",
    "- <b>Mejor solución:</b> [59, 69, 75, 53, 44, 10, 87, 12, 73, 38, 94, 41, 51, 15, 9, 99, 46, 32, 17, 92, 64, 37, 55, 23, 65, 79, 20, 4, 62, 86, 11, 63, 72, 26, 14, 48, 35, 60, 83, 70, 98, 47, 43, 58, 85, 19, 40, 5, 96, 68, 45, 25, 50, 89, 74, 27, 33, 97, 7, 84, 21, 16, 67, 66, 88, 29, 95, 8, 81, 31, 30, 49, 93, 61, 1, 78, 34, 13, 2, 80, 56, 82, 6, 22, 36, 71, 18, 91, 52, 90, 54, 57, 39, 28, 76, 24, 42, 77, 3]\n",
    "- <b> Coste de la solución: </b> 1663.18\n",
    "- <b>Iteración en la que se encuentra la mejor solución (empezando a contar en 1):</b> 4633\n",
    "    \n",
    "    \n",
    "    \n",
    "<b>Prueba adicional con el fichero de grafo50cidadesA.txt</b>:\n",
    "    \n",
    "<b> Solución inicial: </b> \n",
    "- [25, 6, 43, 23, 13, 47, 4, 11, 46, 41, 15, 38, 21, 26, 14, 42, 49, 32, 33, 3, 12, 20, 8, 48, 39, 28, 37, 45, 36, 2, 17, 9, 31, 29, 7, 24, 1, 5, 18, 35, 44, 22, 16, 30, 34, 10, 40, 19, 27]\n",
    "\n",
    "Como resultados, deberías obtener los siguientes:\n",
    "- <b>Mejor solución:</b> [16, 21, 28, 23, 37, 39, 7, 2, 34, 13, 38, 27, 33, 6, 22, 20, 4, 32, 17, 46, 18, 36, 11, 26, 14, 9, 15, 41, 48, 25, 45, 35, 5, 40, 19, 47, 43, 12, 49, 1, 31, 30, 10, 44, 8, 29, 3, 42, 24]\n",
    "- <b> Coste de la solución: </b> 1032.76\n",
    "- <b>Iteración en la que se encuentra la mejor solución (empezando a contar en 1):</b> 4280\n",
    "</div>\n",
    "\n",
    "\n",
    "## Código"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 314,
   "id": "d925ce44",
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "\n",
    "# funcion de generacion de solucion inicial\n",
    "def genera_solucion_inicial(mapa):\n",
    "    lista = [i for i in range(1,mapa.nciudades)]\n",
    "    random.shuffle(lista)\n",
    "    return lista\n",
    "\n",
    "def coste_vecino(s_act, coste_actual, vecino, intercambio, mapa):\n",
    "    coste_nuevo = coste_actual\n",
    "    for cambio in intercambio:\n",
    "        if cambio == 0:\n",
    "            coste_nuevo -= mapa.distancia(0, s_act[cambio])\n",
    "            coste_nuevo -= mapa.distancia(s_act[cambio], s_act[cambio+1])\n",
    "\n",
    "            coste_nuevo += mapa.distancia(0, vecino[cambio])\n",
    "            coste_nuevo += mapa.distancia(vecino[cambio], vecino[cambio+1])\n",
    "        elif cambio == len(s_act)-1:\n",
    "            coste_nuevo -= mapa.distancia(s_act[cambio-1], s_act[cambio])\n",
    "            coste_nuevo -= mapa.distancia(s_act[cambio], 0)\n",
    "\n",
    "            coste_nuevo += mapa.distancia(vecino[cambio-1], vecino[cambio])\n",
    "            coste_nuevo += mapa.distancia(vecino[cambio], 0)\n",
    "        else:\n",
    "            coste_nuevo -= mapa.distancia(s_act[cambio-1], s_act[cambio])\n",
    "            coste_nuevo -= mapa.distancia(s_act[cambio], s_act[cambio+1])\n",
    "\n",
    "            coste_nuevo += mapa.distancia(vecino[cambio-1], vecino[cambio])\n",
    "            coste_nuevo += mapa.distancia(vecino[cambio], vecino[cambio+1])\n",
    "                \n",
    "    return coste_nuevo\n",
    "            \n",
    "    \n",
    "    \n",
    "# funcion de generacion de vencindario\n",
    "def genera_vecindario(s_act, mapa, lista_tabu):\n",
    "    vecindario = []\n",
    "    coste_actual = funcion_coste(s_act, mapa)\n",
    "    for i in range(len(s_act)):\n",
    "        for j in range(i+1,len(s_act)):\n",
    "            intercambio = (i,j)\n",
    "            #Primero miramos si el intercambio está en la lista tabu\n",
    "            if lista_tabu.existe(intercambio) == False:\n",
    "                \n",
    "                vecino = list(s_act)\n",
    "                vecino[i], vecino[j] = vecino[j], vecino[i]\n",
    "\n",
    "                #Aqui implementamos el cálculo del coste del vecino\n",
    "                coste = coste_vecino(s_act, coste_actual, vecino, intercambio, mapa)\n",
    "\n",
    "                vecindario.append([tuple(vecino),intercambio, coste])\n",
    "    \n",
    "    return vecindario\n",
    "    \n",
    "# funcion que implementa el algoritmo búsqueda tabú\n",
    "def busqueda_tabu(MAPA, NUM_CIUDADES, N, MAX_ITS, inicial = []):\n",
    "    if len(inicial)==0:\n",
    "        s_in = genera_solucion_inicial(MAPA)\n",
    "    else:\n",
    "        s_in = inicial\n",
    "    print(\"sin : \", s_in)\n",
    "    s_mejor = s_in\n",
    "    s_act = s_in\n",
    "    lista_tabu = Listatabu(N) #No añadimos nada porque no se ha hecho ningun movimiento todavia\n",
    "    \n",
    "    its_sin_mejora = 0\n",
    "    \n",
    "    for i in range(MAX_ITS):\n",
    "        vecinos = genera_vecindario(s_act, MAPA, lista_tabu)\n",
    "\n",
    "        coste_act = float(\"inf\")\n",
    "\n",
    "        #Tomamos el vecino con menor coste\n",
    "        vecino_menor_coste = min(vecinos, key=lambda elemento: elemento[2])\n",
    "\n",
    "        \n",
    "        s_act = vecino_menor_coste[0]\n",
    "        \n",
    "        \n",
    "        movimiento_s_act = vecino_menor_coste[1]\n",
    "        coste_act = vecino_menor_coste[2]\n",
    "        \n",
    "        \n",
    "        \n",
    "        \n",
    "        if coste_act == float(\"inf\"):\n",
    "            #No hay soluciones mejores, no entiendo bien esto la verdad........\n",
    "            print(\"salimos\")\n",
    "            break\n",
    "        \n",
    "        if coste_act < funcion_coste(s_mejor,MAPA):\n",
    "            s_mejor = s_act\n",
    "            iteracion = i\n",
    "            its_sin_mejora = 0\n",
    "        #Este else es para añadir la reinicializacion\n",
    "        else:\n",
    "            its_sin_mejora += 1\n",
    "            if its_sin_mejora == 1000:\n",
    "                lista_tabu, s_act = reinicializacion(N, s_mejor)\n",
    "                print(lista_tabu, funcion_coste(s_act, MAPA))\n",
    "                its_sin_mejora = 0\n",
    "                continue\n",
    "        \n",
    "        lista_tabu.add(movimiento_s_act)\n",
    "        \n",
    "        if i % 500 == 0:\n",
    "            print(funcion_coste(s_mejor, MAPA), i)\n",
    "        \n",
    "    return (s_mejor, iteracion)\n",
    "\n",
    "def reinicializacion(N, s_mejor):\n",
    "    return (Listatabu(N), s_mejor)\n",
    "\n",
    "\n",
    "def funcion_coste(s, mapa):\n",
    "    cost_tot = 0\n",
    "    cost_tot += mapa.distancia(0,s[0])\n",
    "    for i in range(len(s)-1):\n",
    "        cost_tot += mapa.distancia(s[i], s[i+1])\n",
    "    cost_tot += mapa.distancia(s[len(s)-1], 0)\n",
    "    return cost_tot\n",
    "\n",
    "\n",
    "def diferencia_coste(s_act, s_cand, mapa):\n",
    "    return funcion_coste(s_act, mapa) - funcion_coste(s_cand, mapa)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 315,
   "id": "ec9e3cba",
   "metadata": {},
   "outputs": [],
   "source": [
    "#La lista tabú será un set con un máximo número de elementos\n",
    "class Listatabu:\n",
    "    def __init__(self, max_items):\n",
    "        self.max_items = max_items\n",
    "        self.elementos = []\n",
    "        self.num_elems = len(self.elementos)\n",
    "        \n",
    "    def add(self, elemento):\n",
    "        if self.num_elems == self.max_items:\n",
    "            self.elementos.pop(0)\n",
    "            self.elementos.append(elemento)\n",
    "        else:\n",
    "            self.elementos.append(elemento)\n",
    "            self.num_elems += 1\n",
    "            \n",
    "    def existe(self, elemento):\n",
    "        if elemento in self.elementos:\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "        \n",
    "    def __str__(self):\n",
    "        return str(self.elementos)\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "8f687701",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [2, 1, 4, 7, 6, 3, 5]\n",
      "574.9248805633788 0\n",
      "501.2402797212533 1\n",
      "476.2548964584804 2\n",
      "399.13723055374794 3\n",
      "381.6699617675482 4\n",
      "[] 381.6699617675482\n",
      "[] 381.6699617675482\n",
      "[] 381.6699617675482\n",
      "[] 381.6699617675482\n",
      "[] 381.6699617675482\n",
      "[] 381.6699617675482\n",
      "[] 381.6699617675482\n",
      "[] 381.6699617675482\n",
      "[] 381.6699617675482\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "((1, 2, 3, 4, 5, 6, 7), 4)"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Primera prueba de funcionamiento\n",
    "g3=Localizaciones(filename='./data/grafo100cidades.txt')\n",
    "g1=Localizaciones(filename='./data/grafo8cidades.txt')\n",
    "busqueda_tabu(g1, 8, 8, 10000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "0d6654c8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [77, 9, 43, 73, 2, 53, 12, 83, 92, 33, 50, 63, 54, 59, 64, 74, 55, 14, 35, 5, 58, 87, 37, 7, 69, 79, 89, 21, 23, 80, 20, 56, 75, 68, 27, 95, 78, 25, 88, 51, 47, 91, 49, 60, 13, 36, 70, 42, 11, 22, 40, 72, 28, 97, 19, 71, 29, 90, 85, 76, 16, 24, 81, 84, 34, 8, 31, 38, 67, 45, 44, 32, 96, 10, 61, 94, 17, 18, 93, 30, 52, 66, 99, 26, 46, 39, 15, 86, 41, 4, 62, 1, 48, 82, 57, 98, 3, 65, 6]\n",
      "8294.671201829853 0\n",
      "7916.395842963709 1\n",
      "7566.77657768916 2\n",
      "7263.681215409916 3\n",
      "6962.079603271616 4\n",
      "6660.912115816683 5\n",
      "6385.885741044173 6\n",
      "6117.770156400264 7\n",
      "5865.134148862049 8\n",
      "5659.742758733489 9\n",
      "5463.505448844538 10\n",
      "5287.475547953465 11\n",
      "5128.702988696754 12\n",
      "4971.531148961278 13\n",
      "4824.747014748516 14\n",
      "4700.770048326151 15\n",
      "4587.318641707304 16\n",
      "4483.945870744868 17\n",
      "4385.190190401491 18\n",
      "4294.790398842664 19\n",
      "4229.019402986686 20\n",
      "4120.016193198027 21\n",
      "4054.05506612966 22\n",
      "3983.012552483363 23\n",
      "3929.8856160771306 24\n",
      "3871.994638564865 25\n",
      "3803.8590681339106 26\n",
      "3751.7761973558495 27\n",
      "3703.5647102229013 28\n",
      "3656.6626836917753 29\n",
      "3611.0908003219574 30\n",
      "3569.3925308724 31\n",
      "3533.014068276748 32\n",
      "3496.6012370605167 33\n",
      "3460.747550392418 34\n",
      "3425.064360022588 35\n",
      "3390.8153382780383 36\n",
      "3359.4400400515933 37\n",
      "3328.2172833614895 38\n",
      "3289.1786164113314 39\n",
      "3258.6476544843977 40\n",
      "3228.2822159612356 41\n",
      "3140.3941020591437 42\n",
      "3106.406872878735 43\n",
      "3081.8376677282204 44\n",
      "3058.8824429413125 45\n",
      "3031.1653115297927 46\n",
      "3007.3553541760566 47\n",
      "2985.965577883977 48\n",
      "2965.9135087225523 49\n",
      "2947.215876533148 50\n",
      "2928.104737609056 51\n",
      "2902.6102544471705 52\n",
      "2883.4441011607846 53\n",
      "2867.2096602350066 54\n",
      "2852.3545262725115 55\n",
      "2830.0591606129583 56\n",
      "2798.708522053298 57\n",
      "2780.9049655872604 58\n",
      "2766.2316970634233 59\n",
      "2753.3305341453706 60\n",
      "2740.6368213425485 61\n",
      "2726.0684817618126 62\n",
      "2672.933564750507 63\n",
      "2657.84934325534 64\n",
      "2631.815716566839 65\n",
      "2619.3072392256468 66\n",
      "2606.3719843315644 67\n",
      "2583.7819094614356 68\n",
      "2571.3526486793517 69\n",
      "2560.838272381158 70\n",
      "2550.5890467911518 71\n",
      "2540.855832857449 72\n",
      "2531.404035560993 73\n",
      "2521.973486592906 74\n",
      "2512.6833619829727 75\n",
      "2504.5442662261153 76\n",
      "2486.0324641378934 77\n",
      "2471.968903951257 78\n",
      "2467.312056487842 79\n",
      "2462.44392374668 80\n",
      "2458.0485843234696 81\n",
      "2453.815291221592 82\n",
      "2450.385604886191 83\n",
      "2447.1704230424475 84\n",
      "2434.1746997854793 85\n",
      "2431.266620324695 86\n",
      "2428.5766049329586 87\n",
      "2426.9236931984406 88\n",
      "2425.7770687997318 89\n",
      "2424.658301833291 90\n",
      "2423.7584999330634 91\n",
      "2423.158060728894 92\n",
      "2416.4426949953872 93\n",
      "2409.750735587458 94\n",
      "2399.311734138294 95\n",
      "2394.3658675962624 96\n",
      "2379.9705741340795 97\n",
      "2378.3293576181068 98\n",
      "2376.250537922683 99\n",
      "2375.1111413944154 100\n",
      "2374.6428051783896 101\n",
      "2374.576754759137 102\n",
      "2374.0965410170834 105\n",
      "2369.6983862884163 106\n",
      "2367.7849000776746 107\n",
      "2367.6284272804282 108\n",
      "2364.2491467721807 109\n",
      "2358.420721328884 110\n",
      "2355.7187312901697 111\n",
      "2355.0717073714463 116\n",
      "2349.600096860407 117\n",
      "2348.3081918562916 118\n",
      "2347.6277800211874 119\n",
      "2345.8815815754833 122\n",
      "2344.443552505634 123\n",
      "2343.786029832223 127\n",
      "2343.39654089731 128\n",
      "2338.0775865368328 129\n",
      "2337.888752267992 130\n",
      "2335.95873526743 131\n",
      "2333.5667989909566 132\n",
      "2331.6514643667647 139\n",
      "2325.5207294681827 140\n",
      "2323.278748656242 142\n",
      "2320.3676218631945 143\n",
      "2311.621135494291 144\n",
      "2310.3667165425773 145\n",
      "2306.8860726051694 146\n",
      "2299.891420960105 152\n",
      "2298.5047703936534 153\n",
      "2297.3740986686953 155\n",
      "2295.967241510258 156\n",
      "2281.9611671108587 162\n",
      "2281.525759288783 165\n",
      "2278.92443845796 166\n",
      "2276.058223115235 167\n",
      "2274.138712118254 169\n",
      "2273.8965258877793 170\n",
      "2273.118821888511 175\n",
      "2268.119123246786 176\n",
      "2252.3312454064176 179\n",
      "2246.748886696494 180\n",
      "2223.7063419746646 181\n",
      "2194.338286914434 182\n",
      "2190.00767101766 183\n",
      "2183.4750650284973 184\n",
      "2181.2414390671483 185\n",
      "2180.1443240305794 186\n",
      "2180.1157714713213 187\n",
      "2177.570817404564 188\n",
      "2159.4954430933176 189\n",
      "2155.053182926991 190\n",
      "2154.497493808307 191\n",
      "2145.0786761716654 196\n",
      "2144.6349545318203 197\n",
      "2139.5380149779094 198\n",
      "2118.8675629716663 200\n",
      "2114.435202969127 201\n",
      "2111.654863860931 203\n",
      "2105.5189842561344 204\n",
      "2104.049465709371 205\n",
      "2101.578020973563 206\n",
      "2101.4967311677015 207\n",
      "2091.6186303970894 215\n",
      "2079.4542581087876 216\n",
      "2074.797410645373 217\n",
      "2071.651977877741 218\n",
      "2070.2194168726396 220\n",
      "2068.0689457894105 223\n",
      "2065.583680462201 225\n",
      "2064.706193893161 233\n",
      "2035.5379199228564 236\n",
      "2022.0240951237445 237\n",
      "1980.9507941546879 278\n",
      "1959.2974545164134 279\n",
      "1946.4352589496211 281\n",
      "1941.318333985635 282\n",
      "1931.3812360272918 283\n",
      "1926.084000118236 285\n",
      "1923.6104270729475 307\n",
      "1922.036591649714 308\n",
      "1921.6995737007935 309\n",
      "1919.8593524286832 419\n",
      "1907.6960213969126 421\n",
      "1905.44278403473 430\n",
      "1901.2231773046408 443\n",
      "1896.0534333589233 444\n",
      "1891.7621418433343 446\n",
      "1882.9181800898812 447\n",
      "1880.0872952304856 448\n",
      "1875.9580924855134 449\n",
      "1874.917182349828 450\n",
      "1873.2973395939655 451\n",
      "1869.9356004202052 452\n",
      "1862.8490605688346 455\n",
      "1858.7430670355773 456\n",
      "1857.601019120951 457\n",
      "1855.5917688431382 467\n",
      "1852.446336075506 468\n",
      "1849.6820243284806 469\n",
      "1849.1026387164156 472\n",
      "1848.1322921584435 473\n",
      "1846.9376793071747 478\n",
      "1838.1273455334738 483\n",
      "1837.756605429425 484\n",
      "1837.1044474093542 493\n",
      "1836.6066613352164 494\n",
      "1834.1624627596407 504\n",
      "1833.7756453744917 509\n",
      "1826.805019880723 511\n",
      "1825.68876905452 512\n",
      "1821.1842361175918 513\n",
      "1813.4996192967435 693\n",
      "1807.4075517549888 694\n",
      "1794.8748623455165 695\n",
      "1783.8339575253278 696\n",
      "1780.83815427814 697\n",
      "1779.9965366719796 698\n",
      "[] 1779.9965366719796\n",
      "1775.3307339301284 1699\n",
      "1770.8262009932002 1700\n",
      "1767.0151721857017 1701\n",
      "1765.0903676351438 1702\n",
      "1763.2494170604666 1703\n",
      "1762.9148176860779 1704\n",
      "1760.5566881877978 1705\n",
      "1756.7510416986981 1706\n",
      "1756.216412556945 1707\n",
      "1756.1869433091117 1708\n",
      "1756.1526512975233 2342\n",
      "1754.8229006309964 2346\n",
      "1754.402608336616 2347\n",
      "1747.9075204008943 2349\n",
      "1747.372891259141 2350\n",
      "1740.7557984394364 2352\n",
      "1739.7338004812264 2355\n",
      "1737.6005394370327 2357\n",
      "1735.1114520092851 2358\n",
      "1734.091578801363 2359\n",
      "1733.6588490322645 2685\n",
      "1733.469156138022 2686\n",
      "1729.7785853167277 2687\n",
      "1725.9393874959512 2688\n",
      "1725.8033545291023 2714\n",
      "1721.4716480800778 2715\n",
      "1713.714333724308 2716\n",
      "1710.6049116717106 2717\n",
      "1708.604369137324 2718\n",
      "1707.356459966636 2719\n",
      "1705.1978504130777 2720\n",
      "1702.0311063974016 2721\n",
      "1699.2289858759982 2724\n",
      "1691.113231997708 2725\n",
      "1690.0457784473738 3625\n",
      "[] 1690.0457784473738\n",
      "1678.4563736221671 4626\n",
      "1674.094727596928 4627\n",
      "1669.6623675943888 4628\n",
      "1666.9354435629816 4629\n",
      "1664.802600732759 4630\n",
      "1663.7358401214574 4631\n",
      "1663.180151002773 4632\n",
      "[] 1663.180151002773\n",
      "[] 1663.180151002773\n",
      "[] 1663.180151002773\n",
      "[] 1663.180151002773\n",
      "[] 1663.180151002773\n",
      "(59, 69, 75, 53, 44, 10, 87, 12, 73, 38, 94, 41, 51, 15, 9, 99, 46, 32, 17, 92, 64, 37, 55, 23, 65, 79, 20, 4, 62, 86, 11, 63, 72, 26, 14, 48, 35, 60, 83, 70, 98, 47, 43, 58, 85, 19, 40, 5, 96, 68, 45, 25, 50, 89, 74, 27, 33, 97, 7, 84, 21, 16, 67, 66, 88, 29, 95, 8, 81, 31, 30, 49, 93, 61, 1, 78, 34, 13, 2, 80, 56, 82, 6, 22, 36, 71, 18, 91, 52, 90, 54, 57, 39, 28, 76, 24, 42, 77, 3) 4632\n",
      "coste 1663.180151002773\n"
     ]
    }
   ],
   "source": [
    "#Probamos que la implementación es correcta como indica en el cuadro verde\n",
    "inicial = [77, 9, 43, 73, 2, 53, 12, 83, 92, 33, 50, 63, 54, 59, 64, 74, 55, 14, 35, 5, 58, 87, 37, 7, 69, 79, 89, 21, 23, 80, 20, 56, 75, 68, 27, 95, 78, 25, 88, 51, 47, 91, 49, 60, 13, 36, 70, 42, 11, 22, 40, 72, 28, 97, 19, 71, 29, 90, 85, 76, 16, 24, 81, 84, 34, 8, 31, 38, 67, 45, 44, 32, 96, 10, 61, 94, 17, 18, 93, 30, 52, 66, 99, 26, 46, 39, 15, 86, 41, 4, 62, 1, 48, 82, 57, 98, 3, 65, 6]\n",
    "g3=Localizaciones(filename='./data/grafo100cidades.txt')\n",
    "sol = busqueda_tabu(g3, 100, 100, 10000, inicial)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g3))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "0d1eb768",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [25, 6, 43, 23, 13, 47, 4, 11, 46, 41, 15, 38, 21, 26, 14, 42, 49, 32, 33, 3, 12, 20, 8, 48, 39, 28, 37, 45, 36, 2, 17, 9, 31, 29, 7, 24, 1, 5, 18, 35, 44, 22, 16, 30, 34, 10, 40, 19, 27]\n",
      "4054.49390104184 0\n",
      "3777.1076260840373 1\n",
      "3536.6776030773285 2\n",
      "3324.2486678871355 3\n",
      "3127.8776539147616 4\n",
      "2961.5548252177073 5\n",
      "2798.6893350455744 6\n",
      "2666.9388454322366 7\n",
      "2579.785811723678 8\n",
      "2504.493518114751 9\n",
      "2428.1545392854946 10\n",
      "2382.683577938658 11\n",
      "2328.909908256608 12\n",
      "2283.7842682074725 13\n",
      "2228.3451858759367 14\n",
      "2185.111074213034 15\n",
      "2138.105647084397 16\n",
      "2095.270684517312 17\n",
      "2068.192040537197 18\n",
      "2042.2133627957508 19\n",
      "2010.8063345714875 20\n",
      "1977.169929742249 21\n",
      "1937.6816713259311 22\n",
      "1914.2520668583456 23\n",
      "1887.7781020880764 24\n",
      "1834.9034602314923 25\n",
      "1761.3471762535942 26\n",
      "1737.1155158848792 27\n",
      "1716.8907603959028 28\n",
      "1698.4010742359173 29\n",
      "1673.7243998929127 30\n",
      "1660.7344112436176 31\n",
      "1650.8850670348825 32\n",
      "1602.8815619801476 33\n",
      "1560.996213599206 34\n",
      "1547.1221905245347 35\n",
      "1526.7000519757275 36\n",
      "1496.7957281652605 37\n",
      "1486.8839695351912 38\n",
      "1477.0547730169117 39\n",
      "1469.0443725209793 40\n",
      "1459.9189085477267 41\n",
      "1447.825653224391 42\n",
      "1438.3544467718586 43\n",
      "1430.982868987375 44\n",
      "1427.133868521701 45\n",
      "1424.089385522297 46\n",
      "1421.2382443651932 47\n",
      "1415.3302546788084 48\n",
      "1414.3066939413322 49\n",
      "1413.3068667447778 50\n",
      "1411.283954552853 59\n",
      "1405.3099956143067 60\n",
      "1396.4306851798976 61\n",
      "1375.3598626508917 62\n",
      "1373.6882172248713 63\n",
      "1365.1628760063409 65\n",
      "1364.9102091057032 332\n",
      "1361.5977603619956 333\n",
      "1358.3935827475432 336\n",
      "1353.3715055836294 337\n",
      "1349.2388732484417 537\n",
      "1346.9372797672638 539\n",
      "1342.8664906385386 540\n",
      "1330.8322329543573 542\n",
      "1320.0467984524985 701\n",
      "1298.4392415242705 702\n",
      "1289.3652773067458 703\n",
      "1285.9413125743683 856\n",
      "1277.1313440866722 857\n",
      "1273.9127394769764 858\n",
      "1243.9072220452822 865\n",
      "1208.6033056519589 866\n",
      "1180.7679552505138 867\n",
      "1169.9382110589956 868\n",
      "1169.456588961023 869\n",
      "1158.2093267876967 957\n",
      "1156.95478154146 958\n",
      "1156.1963433005528 965\n",
      "1154.0945096787182 966\n",
      "1153.0460375188345 974\n",
      "1143.3324573405919 991\n",
      "1132.0689114581644 1028\n",
      "1130.693482287754 1029\n",
      "1127.2404270328564 1212\n",
      "1120.5517074662237 1213\n",
      "1109.6795990499152 1222\n",
      "1107.1790918236002 1224\n",
      "1099.9926915659921 1226\n",
      "1099.877994232323 1228\n",
      "1099.4730096806572 1233\n",
      "1094.4509325167435 1234\n",
      "[] 1094.4509325167435\n",
      "1076.9920644350668 2235\n",
      "1075.9922372385124 2236\n",
      "1075.1458600838168 2237\n",
      "1074.6791632541297 2238\n",
      "1059.7216896061686 2244\n",
      "1056.2010390599562 2245\n",
      "1054.607067652508 2248\n",
      "1051.396489922244 2250\n",
      "1051.1105864980857 2256\n",
      "1050.4026960538636 2257\n",
      "1046.4327126235378 2266\n",
      "1041.5423430107564 2267\n",
      "[] 1041.5423430107564\n",
      "1037.541604144924 3268\n",
      "1037.0599820469513 3269\n",
      "1034.073578942937 3277\n",
      "[] 1034.073578942937\n",
      "1033.2272017882415 4278\n",
      "1032.7605049585543 4279\n",
      "[] 1032.7605049585543\n",
      "[] 1032.7605049585543\n",
      "[] 1032.7605049585543\n",
      "[] 1032.7605049585543\n",
      "[] 1032.7605049585543\n",
      "(16, 21, 28, 23, 37, 39, 7, 2, 34, 13, 38, 27, 33, 6, 22, 20, 4, 32, 17, 46, 18, 36, 11, 26, 14, 9, 15, 41, 48, 25, 45, 35, 5, 40, 19, 47, 43, 12, 49, 1, 31, 30, 10, 44, 8, 29, 3, 42, 24) 4279\n",
      "coste 1032.7605049585543\n"
     ]
    }
   ],
   "source": [
    "#Probamos que la implementación es correcta como indica en el cuadro verde\n",
    "inicial = [25, 6, 43, 23, 13, 47, 4, 11, 46, 41, 15, 38, 21, 26, 14, 42, 49, 32, 33, 3, 12, 20, 8, 48, 39, 28, 37, 45, 36, 2, 17, 9, 31, 29, 7, 24, 1, 5, 18, 35, 44, 22, 16, 30, 34, 10, 40, 19, 27]\n",
    "g4=Localizaciones(filename='./data/grafo50cidadesA.txt')\n",
    "sol = busqueda_tabu(g4, 50, 100, 10000, inicial)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g4))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "214a8163",
   "metadata": {},
   "source": [
    "###  **Pregunta 2**\n",
    "\n",
    "La parte experimental de la práctica consiste en realizar **10 ejecuciones diferentes** de la implementación realizada y reportar:\n",
    "- **Media y desviación** estándar de las soluciones obtenidas.\n",
    "- El **número de iteración** en el que se obtuvo la mejor solución (por lo que debéis mantener además de la solución óptima hasta el momento $S_{opt}$, la iteración en la que se obtiene). \n",
    "- El **tiempo de ejecución** del algoritmo (en las nociones previas se explica cómo hacer esto).\n",
    "\n",
    "*Incluye todas las celdas que consideres oportunas para que sea legible y fácil de seguir.*\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "674cc30b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import numpy as np\n",
    "g3=Localizaciones(filename='./data/grafo100cidades.txt') \n",
    "soluciones = []\n",
    "costes = []\n",
    "iteracion = []\n",
    "tiempos = []\n",
    "for i in range(10):\n",
    "    inicial = time.time()\n",
    "    sol = busqueda_tabu(g3, 100, 100, 10000)\n",
    "    final = time.time()\n",
    "    print(\"Tiempo iteracion: \", final-inicial)\n",
    "    soluciones.append(sol[0])\n",
    "    costes.append(funcion_coste(sol[0],g3))\n",
    "    iteracion.append(sol[1])\n",
    "    tiempos.append(final - inicial)\n",
    "    \n",
    "np.save('soluciones_pruebas.npy', np.array(soluciones))\n",
    "np.save('costes_pruebas.npy', np.array(costes))\n",
    "np.save('iteracion_pruebas.npy', np.array(iteracion))\n",
    "np.save('tiempos_pruebas.npy', np.array(tiempos))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "3ce2d089",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Media de costes:  1686.5762513545278\n",
      "Desviacion:  63.60686811966013\n",
      "Minimo:  1595.1355870309062\n",
      "Maximo:  1815.8054148038132\n",
      "Media de tiempos:  241.25566024780272\n",
      "Desviacion:  4.031094443995748\n",
      "Tiempo de la mejor solucion:  236.57311344146729\n",
      "Media de iteracion:  4653\n",
      "Desviacion:  2300.2899817196962\n",
      "Iteracion de la mejor solucion:  9877\n"
     ]
    }
   ],
   "source": [
    "import statistics\n",
    "tiempos = np.load(\"tiempos.npy\")\n",
    "costes = np.load(\"costes.npy\")\n",
    "iteracion = np.load(\"iteracion.npy\")\n",
    "\n",
    "print(\"Media de costes: \", statistics.mean(costes))\n",
    "print(\"Desviacion: \", statistics.stdev(costes))\n",
    "print(\"Minimo: \", min(costes))\n",
    "print(\"Maximo: \", max(costes))\n",
    "print(\"Media de tiempos: \", statistics.mean(tiempos))\n",
    "print(\"Desviacion: \", statistics.stdev(tiempos))\n",
    "print(\"Tiempo de la mejor solucion: \", tiempos[list(costes).index(min(costes))])\n",
    "print(\"Media de iteracion: \", statistics.mean(iteracion))\n",
    "print(\"Desviacion: \", statistics.stdev(iteracion))\n",
    "print(\"Iteracion de la mejor solucion: \", iteracion[list(costes).index(min(costes))])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fc1d87f6",
   "metadata": {
    "tags": []
   },
   "source": [
    "❗  **NOTA: sé conservador en tu estrategia para verificar tu implementación**, especialmente cuando empleas ficheros de datos grandes como el del problema de las 100 ciudades. Si dejas ejecutando tu algoritmo por un número elevado de iteraciones, puede resultarte útil medir el tiempo que tarda para tomar decisiones sobre donde establecer el límite. \n",
    "\n",
    "## P2.2 Implementación de las mejoras (4 pt)\n",
    "\n",
    "### **Pregunta 3** \n",
    "\n",
    "¿Qué intervenciones de mejora te ha llevado a mejores resultados? Prepara un informe en el que explices brevemente las mejoras o intervenciones de mejora realizadas, cómo las has implementado, y diseña un laboratorio para obtener resultados que te permitan explicar porqué las consideras buenas para el problema y soportar tus conclusiones acompañadas de los resultados obtenidos. (MAX. aprox. 1200 palabras)\n",
    "\n",
    "Aclaraciones: La evaluación de esta parte se llevará a cabo en términos de la completitud y correctitud del laboratorio implementado, así como de la calidad del propio informe, que debe ser conciso y preciso, pudiendo acompañarse de gráficas y tablas que faciliten y fundamenten la explicación e argumentación. Es muy importante explicar de manera clara, precisa y fundamentada. Se valorará más positivamente las intervenciones de mejora que tengan mayor dificultad de implementación que las triviales. Se reservará hasta un punto que se asignará en términos de la calidad de la mejor solución obtenida entre el conjunto de las prácticas entregadas (es por ello que no debes olvidar marcar en tu informe muy claramente cuál ha sido tu mejor solución y con qué configuración/versión).\n",
    "\n",
    "*Incluye todas las celdas que consideres oportunas para que sea legible y fácil de seguir*"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d4b1abf9",
   "metadata": {},
   "source": [
    "<h1> INFORME </h1>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f5c113a4",
   "metadata": {},
   "source": [
    "En la primera parte de la práctica se desarrollo el algoritmo de Búsqueda Tabú desde creo. En esta segunda parte, el objetivo es mejorar el algoritmo para obtener soluciones más eficiente y reducir el tiempo de ejecución (que es crítico por el coste del algoritmo). Solo podremos realizar 3 ejecuciones de las versiones básica y final y una siempre con la misma solución inicial de cada mejora por separado, para ver como funcionan. \n",
    "\n",
    "Los resultados obtenidos en la ejecución básica son:\n",
    "\n",
    "|  | 3 veces | 1 vez misma solución |\n",
    "|-----------|-----------|-----------|\n",
    "| **Media costes**   | 33157.258    | 30329.548    |\n",
    "| **Desviacion**   | 2582.655    |     |\n",
    "| **Tiempo medio por iteracion**    | 392.544 s    | 401.495 s    |\n",
    "| **Optima**    | 30329.548   | 30329.548   |\n",
    "| **Encontrada**    | 3106   | 3106   |\n",
    "\n",
    "La solución más óptima se encuentra en la iteración 3106, lo que significa que el 70% del tiempo que el algoritmo se ejecuta es tiempo del que no se obtiene ningún resultado.\n",
    "\n",
    "Las **primeras mejoras** que implementaremos pretender mejorar los tiempos de ejecución del algoritmo, que son actualmente de cerca de 7 minutos. Las primera de las dos mejoras que implementaremos con este fin consiste en modificar el funcionamiento de la lista tabú para que en vez de emplear simplemente una lista donde almacena los intercambios prohibidos, utilice una estructura set (además de la lista para mantener el orden de entrada) en la que la búsqueda de un elemento por su valor es mucho más rápida que recorriendo la lista con un bucle. La segunda mejora consistirá en partir la función de generación de vecindario en dos. En la primera parte generaremos a todos los vecinos de la solución actual y en la segunda calcularemos el coste de los vecinos una vez tengamos la lista entera. Los resultados obtenidos con dichas mejoras son los siguientes:\n",
    "\n",
    "|  | Basica (1 vez) | Utilizando set | Generacion vecindario partida |\n",
    "|-----------|-----------|-----------|--|\n",
    "| **Tiempo**    | 401.495 s    | 298.380 s    | 384.488 s  |\n",
    "\n",
    "La búsqueda en la tabla tabú suponía gran parte del coste temporal del algoritmo, teniendo que recorrer esta continuamente. La posibilidad de buscar un elemento en un set directamente identado por su valor resulta muy favorecedor. La generación del vecindario en dos partes a priori no tiene mucho sentido que mejore el tiempo de ejecución, ya que incluye más bucles en su código. Sin embargo, puede que por cuestiones relacionadas con la capacidad de la caché y la memoria principal la localidad de los datos sea mejor aprovechada en esta segunda versión. Esto podría explicar la mejora.\n",
    "\n",
    "En el resto de versiones del código utilizaremos estas dos mejoras para poder realizar los experimentos en menor tiempo. \n",
    "\n",
    "Las siguientes mejoras ya pretenden obtener soluciones más óptimas. No son muchas las mejoras que han derivado en un beneficio al final.  Han sido muchas las soluciones que han dado resultados mínimamente mejores, pero que han aumentado mucho el número de iteraciones en que se encuentra la mejor solución. Comentaremos todos ellos rápidamente utilizando la siguiente tabla:\n",
    "\n",
    "\n",
    "|  | Básica | Aspiracion | Insercion | Memoria corto plazo |\n",
    "|-----------|-----------|-----------|-----------|-----------|\n",
    "| **Optima**   | 30329.548    | 29250.389    |    31846.470 | 29126.151   | \n",
    "| **Tiempo**    | 401.495 s    | 325.982    |     |  330.593   |  \n",
    "| **Iteracion**    | 3106   | 9105   |   1768 | 9984   | \n",
    "\n",
    "La primera mejora que no ha resultado muy beneficiosa consiste en incluir un criterio de aspiración a la lista tabú. Esto quiere decir, que ciertas soluciones se excluyen de la lista tabú por considerarse que pueden ser muy beneficiosas. En este caso, se ha excluido de la lista a aquellas soluciones que eran mejores que la óptima hasta ese momento. Esto, no ha aportado ningún beneficio, solo ha resultado en una repetitiva vuelta a soluciones ya visitadas, provocando que se encuentre una solución ciertamente muy similar en 2 veces más iteraciones. La mejora de inserción se basaba en la idea de que sería menos radical en una solución intermedia introducir un elemento en una posición diferente que no intercambiar dos elementos entre ellos.  Sin embargo, ocurre que no se adapta bien al algoritmo, y este no consigue profundizar adecuadamente en zonas correctas, quedándose con una solución óptima incluso por debajo de la versión básica. Finalmente, la mejora de memoria a corto plazo utiliza una pila donde se almacenan las N mejores soluciones hasta ese momento. Cuando llega el momento de reinicializar se toma como solución actual la primera obtenida de la pila. Así, no solo volvemos a la mejor solución encontrada, sino también a buenas soluciones anteriores, pretendiendo no dejar atrás otras soluciones diferentes que podrían ser mejores, una vez observamos que no podemos aprovechar más la intensificación de la solución mejor (que será la primera en tomarse de la pila). Esto, como el resto, no ha resultado especialmente bien, mejorando poco la solución óptima y requiriendo muchas más iteraciones.\n",
    "\n",
    "Ahora vamos con las modificaciones que sí han mejorado sustancialmente el rendimiento del algoritmo. La primera de ellas consiste en utilizar un algoritmo voraz en la solución inicial del algoritmo. Con esto, buscamos acotar desde un principio la búsqueda en torno a una solución bastante buena, viendo si así, a través de la intensificación, se puede llegar a una solución mejor. Este algoritmo voraz o greedy pondrá a continuación de la última ciudad en la solución, la ciudad cuya distancia con la anterior sea menor. Los resultados son los siguientes:\n",
    "\n",
    "\n",
    "|  | Coste solucion inicial | Optima | Tiempo | Iteracion |\n",
    "|-----------|-----------|-----------|--|--|\n",
    "| **Greedy**    |   27033.850  | 25619.983    | 318.460 s  | 2385  |\n",
    "\n",
    "Efectivamente consigue lo que se proponía. Parte de una solución muy buena, de 27000, a partir de la cual consigue cierta mejora en un número de iteraciones muy pequeño. El tiempo útil es muy bajo y se consigue una solución muy buena. La mejor hasta el momento. \n",
    "\n",
    "La siguiente mejora consiste en implementar una estrategia diferente de reinicialización llamada diversificación. Esta pretende favorecer a la exploración del espacio de búsqueda reinicializando la solución actual en una que esté en una zona del espacio de búsqueda poco visitada. Para ello, guardaremos una matriz de frecuencias donde para cada par (i,j) donde j es la ciudad siguiente a i, se guarda la cantidad de veces que se ha dado esa situación. Cuando se haga la reinicialización se utilizará el mismo procedimiento greedy que para la solución inicial pero añadiendo al coste de la ciudad i a la ciudad j una cantidad según el valor de Mu y su frecuencia. Así, accederemos a nuevas zonas del espacio no exploradas, pero manteniendo soluciones buenas y coherentes, como ya teníamos en greedy. \n",
    "\n",
    "Para poder combinar exploración y explotación utilizaremos la oscilación estratégica, que alternará aleatoriamente entre intensificación y diversificación. \n",
    "\n",
    " Obtenemos los siguientes resultados:\n",
    "\n",
    "|  | Básica | Diversificacion | Oscilación estratégica u=0.3 sin_mejora=1000| Oscilación estratégica u=0.05 sin_mejora=500\n",
    "|-----------|-----------|-----------|-----------|--|\n",
    "| **Optima**   | 30329.548    | 26036.182    |    25061.940 | 25690.302   | \n",
    "| **Tiempo**    | 401.495 s    | 332.921    |   331.019  |  338.190   |  \n",
    "| **Iteracion**    | 3106   | 7792   |   7792 | 7768   | \n",
    "\n",
    "Con la oscilación estamos introduciendo un componente aleatorio en nuestro algoritmo, lo que hará que la salida del mismo no sea siempre la misma, aún para la misma solución inicial, lo que dificulta la comparación. Por eso es que la diferencia entre diversificación y oscilación estratégica no se aprecia mucho. Tampoco se aprecia cuando jugamos con los parámetros Mu, que determina cuanta importancia tendrá la frecuencia en el cálculo del coste, y la cantidad de iteraciones sin mejora que tienen que pasar para reinicializar. Tras muchas pruebas y por intuición, hemos determinado que los mejores valores de estos parámetros son Mu=0.05 y sin_mejora=500. El valor de Mu se reduce para que los costes de las soluciones con las que se reinicializa disminuyan y sean de alrededor de 30000, un valor intermedio en el rango de soluciones que obtenemos. El número de iteraciones sin mejora antes de reinicializar se disminuye también buscando que se hagan más reinicializaciones, y por tanto más intensificación y diversificación. Si nos excedemos con este valor no le da tiempo al algoritmo ha explotar correctamente el espacio y podemos no obtener buenas soluciones. La oscilación consigue ese balanceo que se busca entre explotar y explorar, dando, como veremos ahora, las mejores soluciones.\n",
    "\n",
    " Utilizando greedy con oscilación se obtienen unos resultados muy similares a utilizar solo oscilación, que será la versión final de nuestro código. Esto depende del componente aleatorio. En comparación con la versión básica ejecutándola 3 veces:\n",
    "\n",
    "\n",
    "|  | 3 veces | Oscilacion u=0.05 y sin_mejora=500 |\n",
    "|-----------|-----------|-----------|\n",
    "| **Media costes**   | 33157.258    | 24303.210    |\n",
    "| **Desviacion**   | 2582.655    |  209.90   |\n",
    "| **Tiempo medio por iteracion**    | 392.544 s    | 323.743 s   |\n",
    "| **Optima**    | 30329.548   | 24102.322   |\n",
    "| **Encontrada**    | 3106   | 6358   |\n",
    "\n",
    "La versión mejorada supera a todos los niveles a la básica. Quizás si se pretendiese la máxima eficiencia temporal lo mejor sería utilizar la versión greedy, que consigue en 1000 iteraciones menos que la básica encontrar una solución mejor. De todas formas, teniendo en cuenta que el algoritmo de Búsqueda Tabú es un algoritmo costoso, creo que la mejor decisión es decantarse por una solución con más tiempo de ejecución, pero también que asegure los mejores resultados posibles; y esa es la que utiliza oscilación con los parámetros mencionados antes. \n",
    "\n",
    "Ejecutaremos 10 veces esta mejor solución para ver cual es la solución más óptima que conseguimos\n",
    "\n",
    "<h3> Se obtiene la mejor solución utilizando \"Oscilacion u=0.05 y sin_mejora=500\". </h3>\n",
    "<h3>Esta solución tiene un coste de 23343.592 y se encuentra en la iteracion 9938. \n",
    "    <h3>La solución es: </h3>\n",
    "<h3>[101, 79, 51, 91, 81, 109, 119, 83, 69, 82, 89, 8, 38, 40, 105, 36, 35, 94, 18, 16, 59, 4, 42, 71, 110, 113, 14, 11, 58, 55, 21, 62, 75, 63, 41, 24, 26, 23, 52, 117, 92, 34, 60, 47, 9, 20, 111, 49, 25, 17, 103, 96, 70, 73, 88, 31, 72, 5, 87, 112, 54, 95, 85, 104, 46, 33, 108, 48, 97, 57, 6, 45, 30, 44, 102, 76, 39, 29, 116, 118, 15, 67, 12, 115, 106, 1, 61, 98, 99, 56, 19, 7, 27, 86, 65, 93, 28, 66, 3, 53, 50, 64, 74, 37, 84, 2, 13, 78, 80, 114, 107, 22, 68, 100, 90, 43, 32, 10, 77]</h3>\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "78d67196",
   "metadata": {},
   "source": [
    "<h2> Pruebas básicas </h2>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "2894568b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [116, 94, 113, 59, 109, 38, 57, 64, 68, 15, 13, 87, 53, 66, 35, 89, 60, 21, 102, 95, 69, 31, 80, 90, 118, 85, 40, 28, 88, 25, 3, 16, 10, 75, 73, 51, 71, 58, 104, 46, 9, 39, 1, 18, 6, 63, 100, 117, 32, 37, 106, 70, 33, 110, 74, 76, 82, 81, 14, 84, 48, 41, 34, 29, 56, 20, 78, 22, 12, 115, 54, 93, 83, 8, 61, 105, 101, 77, 11, 86, 103, 42, 4, 79, 45, 99, 5, 62, 72, 55, 112, 65, 23, 30, 52, 97, 36, 17, 91, 98, 7, 92, 49, 47, 27, 119, 50, 44, 67, 19, 26, 107, 2, 111, 108, 114, 43, 24, 96]\n",
      "178324.705672494 0\n",
      "35670.77386265365 500\n",
      "35063.95784741774 1000\n",
      "34042.567189425405 1500\n",
      "34042.567189425405 2000\n",
      "33922.90206866632 2500\n",
      "33922.90206866632 3000\n",
      "[] 33922.90206866632\n",
      "33750.65656737128 3500\n",
      "33750.65656737128 4000\n",
      "[] 33750.65656737128\n",
      "33750.65656737128 4500\n",
      "33750.65656737128 5000\n",
      "[] 33750.65656737128\n",
      "33750.65656737128 5500\n",
      "33750.65656737128 6000\n",
      "[] 33750.65656737128\n",
      "33750.65656737128 6500\n",
      "33750.65656737128 7000\n",
      "[] 33750.65656737128\n",
      "33750.65656737128 7500\n",
      "33750.65656737128 8000\n",
      "[] 33750.65656737128\n",
      "33750.65656737128 8500\n",
      "33750.65656737128 9000\n",
      "[] 33750.65656737128\n",
      "33750.65656737128 9500\n",
      "Tiempo iteracion:  392.3152132034302\n",
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "31038.203114984102 3000\n",
      "[] 31038.203114984102\n",
      "30329.548030619946 3500\n",
      "30329.548030619946 4000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 4500\n",
      "30329.548030619946 5000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 5500\n",
      "30329.548030619946 6000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 6500\n",
      "30329.548030619946 7000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 7500\n",
      "30329.548030619946 8000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 8500\n",
      "30329.548030619946 9000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 9500\n",
      "Tiempo iteracion:  388.30961418151855\n",
      "sin :  [115, 71, 88, 112, 21, 39, 66, 47, 108, 73, 34, 19, 67, 107, 96, 6, 83, 64, 80, 32, 79, 23, 16, 53, 93, 5, 116, 95, 11, 113, 74, 7, 48, 91, 86, 82, 98, 37, 104, 50, 33, 10, 13, 4, 42, 41, 59, 45, 26, 72, 109, 22, 97, 9, 30, 87, 85, 2, 29, 106, 68, 15, 101, 56, 35, 8, 110, 31, 36, 94, 12, 55, 28, 49, 62, 24, 61, 90, 81, 1, 100, 25, 54, 46, 111, 57, 76, 38, 43, 102, 118, 63, 119, 99, 40, 84, 103, 70, 69, 51, 44, 27, 77, 78, 52, 14, 18, 75, 114, 89, 60, 92, 117, 65, 17, 58, 105, 20, 3]\n",
      "167338.7983161497 0\n",
      "40023.22368009857 500\n",
      "37323.16207802999 1000\n",
      "36315.195912158524 1500\n",
      "36003.75739936626 2000\n",
      "35835.27761262262 2500\n",
      "35581.539336309674 3000\n",
      "35581.539336309674 3500\n",
      "[] 35581.539336309674\n",
      "35391.569450659335 4000\n",
      "35391.569450659335 4500\n",
      "[] 35391.569450659335\n",
      "35391.569450659335 5000\n",
      "35391.569450659335 5500\n",
      "[] 35391.569450659335\n",
      "35391.569450659335 6000\n",
      "35391.569450659335 6500\n",
      "[] 35391.569450659335\n",
      "35391.569450659335 7000\n",
      "35391.569450659335 7500\n",
      "[] 35391.569450659335\n",
      "35391.569450659335 8000\n",
      "35391.569450659335 8500\n",
      "[] 35391.569450659335\n",
      "35391.569450659335 9000\n",
      "35391.569450659335 9500\n",
      "[] 35391.569450659335\n",
      "Tiempo iteracion:  397.0057330131531\n"
     ]
    }
   ],
   "source": [
    "#PRUEBAS DE LA VERSIÓN BÁSICA CON MAPA DE 120 CIUDADES. 3 repeticiones\n",
    "import time\n",
    "import numpy as np\n",
    "g5=Localizaciones(filename='./data/US120.txt') \n",
    "soluciones = []\n",
    "costes = []\n",
    "iteracion = []\n",
    "tiempos = []\n",
    "for i in range(3):\n",
    "    inicial = time.time()\n",
    "    sol = busqueda_tabu(g5, 120, 100, 10000)\n",
    "    final = time.time()\n",
    "    print(\"Tiempo iteracion: \", final-inicial)\n",
    "    soluciones.append(sol[0])\n",
    "    costes.append(funcion_coste(sol[0],g5))\n",
    "    iteracion.append(sol[1])\n",
    "    tiempos.append(final - inicial)\n",
    "    \n",
    "np.save('soluciones_basica.npy', np.array(soluciones))\n",
    "np.save('costes_basica.npy', np.array(costes))\n",
    "np.save('iteracion_basica.npy', np.array(iteracion))\n",
    "np.save('tiempos_basica.npy', np.array(tiempos))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "34174a14",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Media de costes:  33157.25801621685\n",
      "Desviacion:  2582.6549507471045\n",
      "Minimo:  30329.548030619946\n",
      "Maximo:  35391.569450659335\n",
      "Media de tiempos:  392.5435201327006\n",
      "Desviacion:  4.352552552691559\n",
      "Tiempo de la mejor solucion:  388.30961418151855\n",
      "Media de iteracion:  3383\n",
      "Desviacion:  517.4640084102468\n",
      "Iteracion de la mejor solucion:  3106\n"
     ]
    }
   ],
   "source": [
    "import statistics\n",
    "tiempos = np.load(\"tiempos_basica.npy\")\n",
    "costes = np.load(\"costes_basica.npy\")\n",
    "iteracion = np.load(\"iteracion_basica.npy\")\n",
    "\n",
    "print(\"Media de costes: \", statistics.mean(costes))\n",
    "print(\"Desviacion: \", statistics.stdev(costes))\n",
    "print(\"Minimo: \", min(costes))\n",
    "print(\"Maximo: \", max(costes))\n",
    "print(\"Media de tiempos: \", statistics.mean(tiempos))\n",
    "print(\"Desviacion: \", statistics.stdev(tiempos))\n",
    "print(\"Tiempo de la mejor solucion: \", tiempos[list(costes).index(min(costes))])\n",
    "print(\"Media de iteracion: \", statistics.mean(iteracion))\n",
    "print(\"Desviacion: \", statistics.stdev(iteracion))\n",
    "print(\"Iteracion de la mejor solucion: \", iteracion[list(costes).index(min(costes))])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "5d9e38d1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "31038.203114984102 3000\n",
      "[] 31038.203114984102\n",
      "30329.548030619946 3500\n",
      "30329.548030619946 4000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 4500\n",
      "30329.548030619946 5000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 5500\n",
      "30329.548030619946 6000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 6500\n",
      "30329.548030619946 7000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 7500\n",
      "30329.548030619946 8000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 8500\n",
      "30329.548030619946 9000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 9500\n",
      "Tiempo que ha tardado:  401.49460530281067\n",
      "(11, 41, 23, 52, 117, 92, 34, 9, 111, 20, 116, 29, 39, 76, 102, 44, 30, 45, 6, 57, 97, 48, 85, 95, 31, 27, 93, 28, 3, 53, 50, 59, 16, 35, 94, 18, 66, 99, 98, 19, 72, 54, 112, 87, 5, 118, 15, 67, 12, 115, 106, 1, 61, 56, 7, 47, 60, 49, 70, 73, 88, 104, 33, 108, 46, 96, 103, 17, 25, 86, 65, 21, 55, 64, 74, 37, 84, 2, 83, 69, 82, 71, 42, 4, 36, 105, 40, 38, 8, 32, 43, 90, 100, 68, 22, 107, 114, 80, 78, 77, 10, 101, 79, 51, 91, 81, 109, 13, 110, 113, 26, 24, 63, 75, 62, 58, 14, 89, 119) 3106\n",
      "coste 30329.548030619946\n"
     ]
    }
   ],
   "source": [
    "#PRUEBA CON UNA SOLUCIÓN INICIAL FIJA Y LA VERSION BÁSICA\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c2655372",
   "metadata": {},
   "source": [
    "<h2> Mejoras Temporales </h2>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "662211d1",
   "metadata": {},
   "source": [
    "<h3> Utilizar un diccionario en la lista tabú, además de una lista para conocer el orden </h3>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 316,
   "id": "fd40ca63",
   "metadata": {},
   "outputs": [],
   "source": [
    "#La primera mejora es que la lista tabú utilice una lista y un diccionario, al mismo tiempo, para conseguir que la búsqueda sea más rapida. \n",
    "#La lista tabú será un set con un máximo número de elementos\n",
    "class Listatabu:\n",
    "    def __init__(self, max_items):\n",
    "        self.max_items = max_items\n",
    "        self.elementos_lista = []\n",
    "        self.num_elems = len(self.elementos_lista)\n",
    "        self.elementos_set = set()\n",
    "        \n",
    "    def add(self, elemento):\n",
    "        if self.num_elems == self.max_items:\n",
    "            eliminado = self.elementos_lista.pop(0)\n",
    "            self.elementos_lista.append(elemento)\n",
    "            self.elementos_set.remove(eliminado)\n",
    "            self.elementos_set.add(elemento)\n",
    "        else:\n",
    "            self.elementos_lista.append(elemento)\n",
    "            self.elementos_set.add(elemento)\n",
    "            self.num_elems += 1\n",
    "            \n",
    "    def existe(self, elemento):\n",
    "        if elemento in self.elementos_set:\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "        \n",
    "    def __str__(self):\n",
    "        return str(self.elementos_lista)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "222b48a8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "31038.203114984102 3000\n",
      "[] 31038.203114984102\n",
      "30329.548030619946 3500\n",
      "30329.548030619946 4000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 4500\n",
      "30329.548030619946 5000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 5500\n",
      "30329.548030619946 6000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 6500\n",
      "30329.548030619946 7000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 7500\n",
      "30329.548030619946 8000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 8500\n",
      "30329.548030619946 9000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 9500\n",
      "Tiempo que ha tardado:  298.3795154094696\n",
      "(11, 41, 23, 52, 117, 92, 34, 9, 111, 20, 116, 29, 39, 76, 102, 44, 30, 45, 6, 57, 97, 48, 85, 95, 31, 27, 93, 28, 3, 53, 50, 59, 16, 35, 94, 18, 66, 99, 98, 19, 72, 54, 112, 87, 5, 118, 15, 67, 12, 115, 106, 1, 61, 56, 7, 47, 60, 49, 70, 73, 88, 104, 33, 108, 46, 96, 103, 17, 25, 86, 65, 21, 55, 64, 74, 37, 84, 2, 83, 69, 82, 71, 42, 4, 36, 105, 40, 38, 8, 32, 43, 90, 100, 68, 22, 107, 114, 80, 78, 77, 10, 101, 79, 51, 91, 81, 109, 13, 110, 113, 26, 24, 63, 75, 62, 58, 14, 89, 119) 3106\n",
      "coste 30329.548030619946\n"
     ]
    }
   ],
   "source": [
    "#PRUEBA DE LA MEJORA DE TIEMPO CON DICCIONARIO. SOLO CON UNA SOLUCIÓN INICIAL FIJA\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d2a6ff39",
   "metadata": {},
   "source": [
    "<h3> Primero generar el vecindario y después calcular el coste de los vecinos, no todo en el mismo bucle </h3>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 317,
   "id": "1577e5fb",
   "metadata": {},
   "outputs": [],
   "source": [
    "#LO SIGUIENTE QUE PROBAMOS PARA MEJORAR EL TIEMPO ES PRIMERO GENERAR EL VECINDARIO Y LUEGO CALCULAR LOS COSTES\n",
    "def busqueda_tabu(MAPA, NUM_CIUDADES, N, MAX_ITS, inicial = []):\n",
    "    #print(MAPA, NUM_CIUDADES, N, MAX_ITS)\n",
    "    if len(inicial)==0:\n",
    "        s_in = genera_solucion_inicial(MAPA)\n",
    "    else:\n",
    "        s_in = inicial\n",
    "    print(\"sin : \", s_in)\n",
    "    s_mejor = s_in\n",
    "    s_act = s_in\n",
    "    lista_tabu = Listatabu(N) #No añadimos nada porque no se ha hecho ningun movimiento todavia\n",
    "    \n",
    "    its_sin_mejora = 0\n",
    "    \n",
    "    for i in range(MAX_ITS):\n",
    "        vecinos = genera_vecindario(s_act)\n",
    "        #Ahora calcularemos el coste de todos los vecinos y lo haremos parte de la tupla (vecino, movimiento, coste)\n",
    "        vecinos = coste_vecinos(s_act, vecinos, MAPA)\n",
    "        coste_act = float(\"inf\")\n",
    "        for vecino in vecinos:\n",
    "            #print(vecino)\n",
    "\n",
    "            if lista_tabu.existe(vecino[1]) == False and vecino[2] < coste_act:\n",
    "                s_act = vecino[0]\n",
    "                movimiento_s_act = vecino[1]\n",
    "                coste_act = vecino[2] \n",
    "        if coste_act == float(\"inf\"):\n",
    "            #No hay soluciones mejores, no entiendo bien esto la verdad........\n",
    "            print(\"salimos\")\n",
    "            break\n",
    "        if coste_act < funcion_coste(s_mejor, MAPA):\n",
    "            s_mejor = s_act\n",
    "            iteracion = i\n",
    "            its_sin_mejora = 0\n",
    "        #Este else es para añadir la reinicializacion\n",
    "        else:\n",
    "            its_sin_mejora += 1\n",
    "            if its_sin_mejora == 1000:\n",
    "                lista_tabu, s_act = reinicializacion(N, s_mejor)\n",
    "                print(lista_tabu, funcion_coste(s_act, MAPA))\n",
    "                its_sin_mejora = 0\n",
    "                continue\n",
    "            \n",
    "        \n",
    "        lista_tabu.add(movimiento_s_act)\n",
    "        \n",
    "        if i % 500 == 0:\n",
    "            print(funcion_coste(s_mejor, MAPA), i)\n",
    "        \n",
    "    return (s_mejor, iteracion)\n",
    "\n",
    "def coste_vecinos(s_act, vecinos, mapa):\n",
    "    coste_actual = funcion_coste(s_act, mapa)\n",
    "    for vecino in vecinos:\n",
    "        coste_nuevo = coste_actual\n",
    "        for intercambio in vecino[1]:\n",
    "            if intercambio == 0:\n",
    "                coste_nuevo -= mapa.distancia(0, s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], s_act[intercambio+1])\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(0, vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], vecino[0][intercambio+1])\n",
    "            elif intercambio == len(s_act)-1:\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio-1], s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], 0)\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio-1], vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], 0)\n",
    "            else:\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio-1], s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], s_act[intercambio+1])\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio-1], vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], vecino[0][intercambio+1])\n",
    "                \n",
    "        vecino.append(coste_nuevo)\n",
    "    \n",
    "    return vecinos\n",
    "\n",
    "# funcion de generacion de vencindario\n",
    "def genera_vecindario(s_act):\n",
    "    vecindario = []\n",
    "    for i in range(len(s_act)):\n",
    "        for j in range(i+1,len(s_act)):\n",
    "            vecino = list(s_act)\n",
    "            vecino[i], vecino[j] = vecino[j], vecino[i]\n",
    "            vecindario.append([tuple(vecino),(i,j)])\n",
    "    \n",
    "    return vecindario"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "cf9e7477",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "31038.203114984102 3000\n",
      "[] 31038.203114984102\n",
      "30329.548030619946 3500\n",
      "30329.548030619946 4000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 4500\n",
      "30329.548030619946 5000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 5500\n",
      "30329.548030619946 6000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 6500\n",
      "30329.548030619946 7000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 7500\n",
      "30329.548030619946 8000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 8500\n",
      "30329.548030619946 9000\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 9500\n",
      "Tiempo que ha tardado:  384.4875886440277\n",
      "(11, 41, 23, 52, 117, 92, 34, 9, 111, 20, 116, 29, 39, 76, 102, 44, 30, 45, 6, 57, 97, 48, 85, 95, 31, 27, 93, 28, 3, 53, 50, 59, 16, 35, 94, 18, 66, 99, 98, 19, 72, 54, 112, 87, 5, 118, 15, 67, 12, 115, 106, 1, 61, 56, 7, 47, 60, 49, 70, 73, 88, 104, 33, 108, 46, 96, 103, 17, 25, 86, 65, 21, 55, 64, 74, 37, 84, 2, 83, 69, 82, 71, 42, 4, 36, 105, 40, 38, 8, 32, 43, 90, 100, 68, 22, 107, 114, 80, 78, 77, 10, 101, 79, 51, 91, 81, 109, 13, 110, 113, 26, 24, 63, 75, 62, 58, 14, 89, 119) 3106\n",
      "coste 30329.548030619946\n"
     ]
    }
   ],
   "source": [
    "#PRUEBA DE LA MEJORA DE TIEMPO CON SEPARACION DE GENERACION DE VECINOS Y SUS COSTES. SOLO CON UNA SOLUCIÓN INICIAL FIJA\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aee6bf41",
   "metadata": {},
   "source": [
    "<h2> Mejoras de soluciones </h2>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "668118d9",
   "metadata": {},
   "source": [
    "<h3> Inicialización de la primera solución utilizando un algoritmo voraz que pone a continuación de una ciudad la más cercana a esta </h3>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 334,
   "id": "7fa84f2d",
   "metadata": {},
   "outputs": [],
   "source": [
    "#La \n",
    "def genera_solucion_inicial(mapa):\n",
    "    solucion = [0]\n",
    "    ciudades_restantes = [i for i in range(1,mapa.nciudades)]\n",
    "    while len(ciudades_restantes)!=0:\n",
    "        ciudad_actual = solucion[-1]\n",
    "        menor_coste = float(\"inf\")\n",
    "        for ciudad in ciudades_restantes:\n",
    "            coste = mapa.distancia(ciudad_actual, ciudad)\n",
    "            if coste < menor_coste:\n",
    "                menor_coste = coste\n",
    "                ciudad_mas_cercana = ciudad\n",
    "        \n",
    "        solucion.append(ciudad_mas_cercana)\n",
    "        ciudades_restantes.remove(ciudad_mas_cercana)\n",
    "        \n",
    "    solucion.pop(0)\n",
    "    return solucion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "id": "69d99d6c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [91, 81, 109, 119, 89, 8, 40, 38, 105, 36, 42, 4, 59, 16, 35, 94, 18, 66, 3, 53, 50, 64, 74, 37, 84, 2, 69, 83, 82, 13, 78, 80, 114, 107, 77, 10, 101, 79, 51, 22, 68, 90, 100, 43, 32, 71, 110, 113, 14, 58, 11, 62, 75, 63, 41, 24, 21, 55, 28, 93, 65, 27, 86, 47, 60, 9, 111, 20, 49, 25, 17, 92, 34, 117, 52, 23, 103, 96, 70, 73, 88, 31, 72, 54, 112, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 102, 44, 76, 39, 29, 116, 87, 5, 118, 15, 67, 12, 61, 115, 106, 1, 98, 99, 56, 7, 19, 104, 46, 26]\n",
      "26848.657520994584 0\n",
      "26302.46268665838 500\n",
      "26302.46268665838 1000\n",
      "[] 26302.46268665838\n",
      "25637.707278609778 1500\n",
      "25637.707278609778 2000\n",
      "[] 25637.707278609778\n",
      "25619.983016850816 2500\n",
      "25619.983016850816 3000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 3500\n",
      "25619.983016850816 4000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 4500\n",
      "25619.983016850816 5000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 5500\n",
      "25619.983016850816 6000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 6500\n",
      "25619.983016850816 7000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 7500\n",
      "25619.983016850816 8000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 8500\n",
      "25619.983016850816 9000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 9500\n",
      "Tiempo iteracion:  318.45952892303467\n",
      "sin :  [91, 81, 109, 119, 89, 8, 40, 38, 105, 36, 42, 4, 59, 16, 35, 94, 18, 66, 3, 53, 50, 64, 74, 37, 84, 2, 69, 83, 82, 13, 78, 80, 114, 107, 77, 10, 101, 79, 51, 22, 68, 90, 100, 43, 32, 71, 110, 113, 14, 58, 11, 62, 75, 63, 41, 24, 21, 55, 28, 93, 65, 27, 86, 47, 60, 9, 111, 20, 49, 25, 17, 92, 34, 117, 52, 23, 103, 96, 70, 73, 88, 31, 72, 54, 112, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 102, 44, 76, 39, 29, 116, 87, 5, 118, 15, 67, 12, 61, 115, 106, 1, 98, 99, 56, 7, 19, 104, 46, 26]\n",
      "26848.657520994584 0\n",
      "26302.46268665838 500\n",
      "26302.46268665838 1000\n",
      "[] 26302.46268665838\n",
      "25637.707278609778 1500\n",
      "25637.707278609778 2000\n",
      "[] 25637.707278609778\n",
      "25619.983016850816 2500\n",
      "25619.983016850816 3000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 3500\n",
      "25619.983016850816 4000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 4500\n",
      "25619.983016850816 5000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 5500\n",
      "25619.983016850816 6000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 6500\n",
      "25619.983016850816 7000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 7500\n",
      "25619.983016850816 8000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 8500\n",
      "25619.983016850816 9000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 9500\n",
      "Tiempo iteracion:  317.20678973197937\n",
      "sin :  [91, 81, 109, 119, 89, 8, 40, 38, 105, 36, 42, 4, 59, 16, 35, 94, 18, 66, 3, 53, 50, 64, 74, 37, 84, 2, 69, 83, 82, 13, 78, 80, 114, 107, 77, 10, 101, 79, 51, 22, 68, 90, 100, 43, 32, 71, 110, 113, 14, 58, 11, 62, 75, 63, 41, 24, 21, 55, 28, 93, 65, 27, 86, 47, 60, 9, 111, 20, 49, 25, 17, 92, 34, 117, 52, 23, 103, 96, 70, 73, 88, 31, 72, 54, 112, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 102, 44, 76, 39, 29, 116, 87, 5, 118, 15, 67, 12, 61, 115, 106, 1, 98, 99, 56, 7, 19, 104, 46, 26]\n",
      "26848.657520994584 0\n",
      "26302.46268665838 500\n",
      "26302.46268665838 1000\n",
      "[] 26302.46268665838\n",
      "25637.707278609778 1500\n",
      "25637.707278609778 2000\n",
      "[] 25637.707278609778\n",
      "25619.983016850816 2500\n",
      "25619.983016850816 3000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 3500\n",
      "25619.983016850816 4000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 4500\n",
      "25619.983016850816 5000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 5500\n",
      "25619.983016850816 6000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 6500\n",
      "25619.983016850816 7000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 7500\n",
      "25619.983016850816 8000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 8500\n",
      "25619.983016850816 9000\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 9500\n",
      "Tiempo iteracion:  320.58117175102234\n"
     ]
    }
   ],
   "source": [
    "#PRUEBA INICIALIZACION GREEDY\n",
    "import time\n",
    "import numpy as np\n",
    "g5=Localizaciones(filename='./data/US120.txt') \n",
    "soluciones = []\n",
    "costes = []\n",
    "iteracion = []\n",
    "tiempos = []\n",
    "for i in range(3):\n",
    "    inicial = time.time()\n",
    "    sol = busqueda_tabu(g5, 120, 100, 10000)\n",
    "    final = time.time()\n",
    "    print(\"Tiempo iteracion: \", final-inicial)\n",
    "    soluciones.append(sol[0])\n",
    "    costes.append(funcion_coste(sol[0],g5))\n",
    "    iteracion.append(sol[1])\n",
    "    tiempos.append(final - inicial)\n",
    "    \n",
    "np.save('soluciones_greedy.npy', np.array(soluciones))\n",
    "np.save('costes_greedy.npy', np.array(costes))\n",
    "np.save('iteracion_greedy.npy', np.array(iteracion))\n",
    "np.save('tiempos_greedy.npy', np.array(tiempos))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 322,
   "id": "cb26f94b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "27033.84988200304"
      ]
     },
     "execution_count": 322,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "funcion_coste([91, 81, 109, 119, 89, 8, 40, 38, 105, 36, 42, 4, 59, 16, 35, 94, 18, 66, 3, 53, 50, 64, 74, 37, 84, 2, 69, 83, 82, 13, 78, 80, 114, 107, 77, 10, 101, 79, 51, 22, 68, 90, 100, 43, 32, 71, 110, 113, 14, 58, 11, 62, 75, 63, 41, 24, 21, 55, 28, 93, 65, 27, 86, 47, 60, 9, 111, 20, 49, 25, 17, 92, 34, 117, 52, 23, 103, 96, 70, 73, 88, 31, 72, 54, 112, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 102, 44, 76, 39, 29, 116, 87, 5, 118, 15, 67, 12, 61, 115, 106, 1, 98, 99, 56, 7, 19, 104, 46, 26], g5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 321,
   "id": "c700f787",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Media de costes:  25619.983016850816\n",
      "Desviacion:  0.0\n",
      "Minimo:  25619.983016850816\n",
      "Maximo:  25619.983016850816\n",
      "Media de tiempos:  318.7491634686788\n",
      "Desviacion:  1.7057343375018819\n",
      "Tiempo de la mejor solucion:  318.45952892303467\n",
      "Media de iteracion:  2385\n",
      "Desviacion:  0.0\n",
      "Iteracion de la mejor solucion:  2385\n"
     ]
    }
   ],
   "source": [
    "import statistics\n",
    "tiempos = np.load(\"tiempos_greedy.npy\")\n",
    "costes = np.load(\"costes_greedy.npy\")\n",
    "iteracion = np.load(\"iteracion_greedy.npy\")\n",
    "\n",
    "print(\"Media de costes: \", statistics.mean(costes))\n",
    "print(\"Desviacion: \", statistics.stdev(costes))\n",
    "print(\"Minimo: \", min(costes))\n",
    "print(\"Maximo: \", max(costes))\n",
    "print(\"Media de tiempos: \", statistics.mean(tiempos))\n",
    "print(\"Desviacion: \", statistics.stdev(tiempos))\n",
    "print(\"Tiempo de la mejor solucion: \", tiempos[list(costes).index(min(costes))])\n",
    "print(\"Media de iteracion: \", statistics.mean(iteracion))\n",
    "print(\"Desviacion: \", statistics.stdev(iteracion))\n",
    "print(\"Iteracion de la mejor solucion: \", iteracion[list(costes).index(min(costes))])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "51ba2d3b",
   "metadata": {},
   "source": [
    "<h3> Pruebas de mejora de aspiración </h3>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 129,
   "id": "c4490c3e",
   "metadata": {},
   "outputs": [],
   "source": [
    "#La siguiente mejora que vamos a implementar es crear una lista de aspiracion que recoja las 5 mejores soluciones hasta el momento y no las introduzca en la lista tabú\n",
    "def busqueda_tabu(MAPA, NUM_CIUDADES, N, MAX_ITS, N_ASPIRACION = 5, inicial = []):\n",
    "    if len(inicial)==0:\n",
    "        s_in = genera_solucion_inicial(MAPA)\n",
    "    else:\n",
    "        s_in = inicial\n",
    "    print(\"sin : \", s_in)\n",
    "    s_mejor = s_in\n",
    "    s_act = s_in\n",
    "    lista_tabu = Listatabu(N) #No añadimos nada porque no se ha hecho ningun movimiento todavia\n",
    "    \n",
    "    mejor = False\n",
    "\n",
    "\n",
    "    \n",
    "    its_sin_mejora = 0\n",
    "    \n",
    "    for i in range(MAX_ITS):\n",
    "        vecinos = genera_vecindario(s_act)\n",
    "        #Ahora calcularemos el coste de todos los vecinos y lo haremos parte de la tupla (vecino, movimiento, coste)\n",
    "        vecinos = coste_vecinos(s_act, vecinos, MAPA)\n",
    "        coste_act = float(\"inf\")\n",
    "        for vecino in vecinos:\n",
    "\n",
    "            if (lista_tabu.existe(vecino[1]) == False or vecino[2] < coste_mejor) and vecino[2] < coste_act and vecino[2] - coste_act != -4.547473508864641e-13:\n",
    "                s_act = vecino[0]\n",
    "                movimiento_s_act = vecino[1]\n",
    "                coste_act = vecino[2] \n",
    "        if coste_act == float(\"inf\"):\n",
    "            #No hay soluciones mejores, no entiendo bien esto la verdad........\n",
    "            print(\"salimos\")\n",
    "            break\n",
    "        if coste_act < funcion_coste(s_mejor, MAPA):\n",
    "            s_mejor = s_act\n",
    "            coste_mejor = funcion_coste(s_mejor, MAPA)\n",
    "            iteracion = i\n",
    "            its_sin_mejora = 0\n",
    "            mejor = True\n",
    "\n",
    "        else:\n",
    "            its_sin_mejora += 1\n",
    "  \n",
    "            if its_sin_mejora == 1000:\n",
    "                lista_tabu, s_act = reinicializacion(N, s_mejor)\n",
    "                print(lista_tabu, funcion_coste(s_act, MAPA))\n",
    "                its_sin_mejora = 0\n",
    "                continue\n",
    "            \n",
    "        if lista_tabu.existe(movimiento_s_act) == False:\n",
    "            lista_tabu.add(movimiento_s_act)\n",
    "        \n",
    "        \n",
    "        if i % 500 == 0:\n",
    "            print(funcion_coste(s_mejor, MAPA), i)\n",
    "        \n",
    "    return (s_mejor, iteracion)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "id": "0d1eb2eb",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Listatabu:\n",
    "    def __init__(self, max_items):\n",
    "        self.max_items = max_items\n",
    "        self.elementos_lista = []\n",
    "        self.num_elems = len(self.elementos_lista)\n",
    "        self.elementos_set = set()\n",
    "        \n",
    "    def add(self, elemento):\n",
    "        if elemento in self.elementos_set:\n",
    "            self.elementos_lista.remove(elemento)\n",
    "            self.elementos_lista.append(elemento)\n",
    "        \n",
    "        elif self.num_elems == self.max_items:\n",
    "                \n",
    "\n",
    "            eliminado = self.elementos_lista.pop(0)\n",
    "            self.elementos_lista.append(elemento)\n",
    "            self.elementos_set.remove(eliminado)\n",
    "            self.elementos_set.add(elemento)\n",
    "        else:\n",
    "            self.elementos_lista.append(elemento)\n",
    "            self.elementos_set.add(elemento)\n",
    "            self.num_elems += 1\n",
    "            \n",
    "    def existe(self, elemento):\n",
    "        if elemento in self.elementos_set:\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "        \n",
    "    def __str__(self):\n",
    "        return str(self.elementos_lista)\n",
    "    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "id": "f29127a1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "36527.3918344422 500\n",
      "33878.62620453602 1000\n",
      "33297.05424641329 1500\n",
      "32597.862115368367 2000\n",
      "32597.862115368367 2500\n",
      "31231.525246253466 3000\n",
      "30944.186850154194 3500\n",
      "29797.124353973148 4000\n",
      "29797.124353973148 4500\n",
      "[] 29797.124353973148\n",
      "29695.074249864483 5000\n",
      "29695.074249864483 5500\n",
      "[] 29695.074249864483\n",
      "29665.136177637098 6000\n",
      "29665.136177637098 6500\n",
      "[] 29665.136177637098\n",
      "29665.136177637098 7000\n",
      "29434.404251154938 7500\n",
      "29434.404251154938 8000\n",
      "[] 29434.404251154938\n",
      "29325.871042446797 8500\n",
      "29325.871042446797 9000\n",
      "29250.388810011147 9500\n",
      "Tiempo que ha tardado:  325.98205614089966\n",
      "(82, 74, 64, 55, 21, 47, 60, 54, 112, 87, 116, 29, 39, 76, 102, 44, 30, 45, 6, 57, 97, 48, 108, 33, 85, 95, 5, 98, 99, 94, 38, 43, 32, 8, 40, 105, 36, 35, 59, 16, 18, 66, 56, 7, 19, 118, 15, 67, 12, 115, 106, 1, 61, 20, 111, 9, 49, 25, 17, 103, 96, 46, 104, 72, 31, 88, 73, 70, 34, 92, 117, 52, 23, 41, 75, 86, 27, 65, 93, 28, 3, 53, 50, 4, 42, 71, 89, 119, 109, 81, 91, 107, 114, 100, 90, 68, 22, 10, 101, 79, 51, 77, 80, 78, 13, 83, 69, 2, 110, 113, 11, 26, 24, 63, 62, 58, 14, 37, 84) 9105\n",
      "coste 29250.388810011147\n"
     ]
    }
   ],
   "source": [
    "#Vamos a probar la mejora de aspiracion\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000,30, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "91619189",
   "metadata": {},
   "source": [
    "<h3> Cambiar el método de generación de vecinos por la inserción de elementos en posiciones diferentes en vez de el intercambio de dos elementos </h3>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 318,
   "id": "3e5163ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "#PRUEBA DE INTERCAMBIO CON FUNCION DE COSTE BÁSICA:\n",
    "def genera_vecindario(s_act):\n",
    "    vecindario = []\n",
    "    #print(len(s_act))\n",
    "    for i in range(len(s_act)):\n",
    "        \n",
    "        for j in range(i+1,len(s_act)):\n",
    "            vecino = list(s_act)\n",
    "            elem = vecino.pop(i)\n",
    "            vecino.insert(j, elem)\n",
    "            vecindario.append([tuple(vecino),(i,j)])\n",
    "    \n",
    "    return vecindario\n",
    "\n",
    "def coste_vecinos(s_act, vecinos, mapa):\n",
    "    for vecino in vecinos:\n",
    "        vecino.append(funcion_coste(vecino[0], mapa))\n",
    "    return vecinos"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 319,
   "id": "1844ce03",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "184248.84412234733 0\n",
      "36937.84414994496 500\n",
      "31874.381597225874 1000\n",
      "31874.381597225874 1500\n",
      "[] 31874.381597225874\n",
      "31846.469244589574 2000\n",
      "31846.469244589574 2500\n",
      "[] 31846.469244589574\n",
      "31846.469244589574 3000\n",
      "31846.469244589574 3500\n",
      "[] 31846.469244589574\n",
      "31846.469244589574 4000\n",
      "31846.469244589574 4500\n",
      "[] 31846.469244589574\n",
      "31846.469244589574 5000\n",
      "31846.469244589574 5500\n",
      "[] 31846.469244589574\n",
      "31846.469244589574 6000\n",
      "31846.469244589574 6500\n",
      "[] 31846.469244589574\n",
      "31846.469244589574 7000\n",
      "31846.469244589574 7500\n",
      "[] 31846.469244589574\n",
      "31846.469244589574 8000\n",
      "31846.469244589574 8500\n",
      "[] 31846.469244589574\n",
      "31846.469244589574 9000\n",
      "31846.469244589574 9500\n",
      "[] 31846.469244589574\n",
      "Tiempo que ha tardado:  1591.463764667511\n",
      "(6, 45, 30, 44, 102, 76, 39, 29, 116, 96, 103, 17, 117, 52, 23, 92, 34, 49, 25, 70, 73, 88, 31, 104, 46, 57, 97, 48, 108, 33, 85, 95, 54, 112, 87, 72, 5, 118, 15, 40, 38, 1, 106, 115, 21, 75, 63, 41, 24, 26, 113, 110, 14, 11, 58, 62, 55, 53, 3, 28, 93, 65, 27, 86, 47, 60, 9, 111, 20, 19, 67, 12, 61, 98, 99, 56, 7, 66, 18, 42, 71, 105, 36, 94, 35, 16, 59, 4, 50, 64, 74, 37, 84, 2, 83, 69, 82, 89, 8, 32, 43, 90, 100, 68, 101, 79, 51, 10, 22, 114, 107, 77, 80, 78, 13, 119, 109, 81, 91) 1768\n",
      "coste 31846.469244589574\n"
     ]
    }
   ],
   "source": [
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5885b046",
   "metadata": {},
   "source": [
    "<h3> Reinicialización basándose en la memoria a corto plazo de las últimas mejores soluciones encontradas. Varias pruebas con diferente número de iteraciones sin mejora hasta reinicializacion y tamaño y tipo de estructura de lista </h3>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 186,
   "id": "fede6a84",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Probaremos a utilizar una lista de las mejores soluciones para reinicializar desde ellas. Primero lo hacemos en forma de cola:\n",
    "\n",
    "class Listatabu:\n",
    "    def __init__(self, max_items):\n",
    "        self.max_items = max_items\n",
    "        self.elementos_lista = []\n",
    "        self.num_elems = len(self.elementos_lista)\n",
    "        self.elementos_set = set()\n",
    "        \n",
    "    def add(self, elemento):\n",
    "        if self.num_elems == self.max_items:\n",
    "            eliminado = self.elementos_lista.pop(0)\n",
    "            self.elementos_lista.append(elemento)\n",
    "            self.elementos_set.remove(eliminado)\n",
    "            self.elementos_set.add(elemento)\n",
    "        else:\n",
    "            self.elementos_lista.append(elemento)\n",
    "            self.elementos_set.add(elemento)\n",
    "            self.num_elems += 1\n",
    "            \n",
    "    def primero(self):\n",
    "        eliminado = self.elementos_lista.pop(0)\n",
    "        self.elementos_set.remove(eliminado)\n",
    "        self.num_elems -= 1\n",
    "        return eliminado\n",
    "            \n",
    "    def existe(self, elemento):\n",
    "        if elemento in self.elementos_set:\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "        \n",
    "    def __str__(self):\n",
    "        return str(self.elementos_lista)\n",
    "    \n",
    "def busqueda_tabu(MAPA, NUM_CIUDADES, N, MAX_ITS, N_MEJORES_SOLUCIONES = 3, inicial = []):\n",
    "    #print(MAPA, NUM_CIUDADES, N, MAX_ITS)\n",
    "    if len(inicial)==0:\n",
    "        s_in = genera_solucion_inicial(MAPA)\n",
    "    else:\n",
    "        s_in = inicial\n",
    "    print(\"sin : \", s_in)\n",
    "    s_mejor = s_in\n",
    "    s_act = s_in\n",
    "    lista_tabu = Listatabu(N) #No añadimos nada porque no se ha hecho ningun movimiento todavia\n",
    "    lista_mejores_soluciones = Listatabu(N_MEJORES_SOLUCIONES)\n",
    "    \n",
    "    its_sin_mejora = 0\n",
    "    \n",
    "    for i in range(MAX_ITS):\n",
    "        vecinos = genera_vecindario(s_act)\n",
    "        #Ahora calcularemos el coste de todos los vecinos y lo haremos parte de la tupla (vecino, movimiento, coste)\n",
    "        vecinos = coste_vecinos(s_act, vecinos, MAPA)\n",
    "        coste_act = float(\"inf\")\n",
    "        for vecino in vecinos:\n",
    "\n",
    "            if lista_tabu.existe(vecino[1]) == False and vecino[2] < coste_act:\n",
    "                s_act = vecino[0]\n",
    "                movimiento_s_act = vecino[1]\n",
    "                coste_act = vecino[2] \n",
    "        if coste_act == float(\"inf\"):\n",
    "            #No hay soluciones mejores, no entiendo bien esto la verdad........\n",
    "            print(\"salimos\")\n",
    "            break\n",
    "        if coste_act < funcion_coste(s_mejor, MAPA):\n",
    "            s_mejor = s_act\n",
    "            iteracion = i\n",
    "            its_sin_mejora = 0\n",
    "            lista_mejores_soluciones.add(s_mejor)\n",
    "        #Este else es para añadir la reinicializacion\n",
    "        else:\n",
    "            its_sin_mejora += 1\n",
    "            if its_sin_mejora == 1000:\n",
    "                lista_tabu, s_act = reinicializacion(lista_mejores_soluciones, N)\n",
    "                print(lista_tabu, funcion_coste(s_act, MAPA))\n",
    "                its_sin_mejora = 0\n",
    "                continue\n",
    "            \n",
    "        \n",
    "        lista_tabu.add(movimiento_s_act)\n",
    "        \n",
    "        if i % 500 == 0:\n",
    "            print(funcion_coste(s_mejor, MAPA), i)\n",
    "        \n",
    "    return (s_mejor, iteracion)\n",
    "\n",
    "def reinicializacion(lista_mejores_soluciones, N):\n",
    "    return (Listatabu(N), lista_mejores_soluciones.primero())\n",
    "    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 178,
   "id": "a7e47f49",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "31038.203114984102 3000\n",
      "[] 31177.775292093786\n",
      "30416.447085097734 3500\n",
      "30350.181571637146 4000\n",
      "29867.88636182958 4500\n",
      "29755.47252785513 5000\n",
      "29755.47252785513 5500\n",
      "29565.45036669851 6000\n",
      "29565.45036669851 6500\n",
      "[] 29640.59900514007\n",
      "29129.00522434549 7000\n",
      "29129.00522434549 7500\n",
      "[] 29241.662565235318\n",
      "29129.00522434549 8000\n",
      "29129.00522434549 8500\n",
      "[] 29234.605736570218\n",
      "29129.00522434549 9000\n",
      "29129.00522434549 9500\n",
      "[] 29221.055941841954\n",
      "Tiempo que ha tardado:  330.5934009552002\n",
      "(113, 26, 23, 52, 117, 92, 34, 9, 111, 20, 116, 29, 39, 76, 102, 44, 30, 45, 6, 57, 97, 48, 108, 33, 85, 95, 28, 3, 66, 18, 16, 59, 4, 36, 35, 94, 99, 98, 19, 31, 72, 54, 112, 87, 5, 118, 15, 67, 12, 115, 106, 1, 61, 56, 7, 47, 60, 49, 25, 17, 103, 96, 46, 104, 88, 73, 70, 86, 27, 65, 93, 21, 55, 53, 50, 64, 74, 42, 105, 71, 40, 38, 8, 89, 119, 109, 81, 91, 77, 114, 107, 10, 101, 79, 51, 32, 43, 90, 100, 68, 22, 80, 78, 13, 83, 69, 82, 84, 37, 14, 11, 63, 24, 41, 75, 62, 58, 110, 2) 9984\n",
      "coste 29126.15173167695\n"
     ]
    }
   ],
   "source": [
    "#Probamos el cambio en la reinicialización\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, 5, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 188,
   "id": "ed7ecc2a",
   "metadata": {},
   "outputs": [],
   "source": [
    "#AUMENTANDO LA FRECUENCIA DE REINICIALIZACION:\n",
    "    \n",
    "def busqueda_tabu(MAPA, NUM_CIUDADES, N, MAX_ITS, N_MEJORES_SOLUCIONES = 3, inicial = []):\n",
    "    if len(inicial)==0:\n",
    "        s_in = genera_solucion_inicial(MAPA)\n",
    "    else:\n",
    "        s_in = inicial\n",
    "    print(\"sin : \", s_in)\n",
    "    s_mejor = s_in\n",
    "    s_act = s_in\n",
    "    lista_tabu = Listatabu(N) #No añadimos nada porque no se ha hecho ningun movimiento todavia\n",
    "    lista_mejores_soluciones = Listatabu(N_MEJORES_SOLUCIONES)\n",
    "    \n",
    "    its_sin_mejora = 0\n",
    "    \n",
    "    for i in range(MAX_ITS):\n",
    "        vecinos = genera_vecindario(s_act)\n",
    "        #Ahora calcularemos el coste de todos los vecinos y lo haremos parte de la tupla (vecino, movimiento, coste)\n",
    "        vecinos = coste_vecinos(s_act, vecinos, MAPA)\n",
    "        coste_act = float(\"inf\")\n",
    "        for vecino in vecinos:\n",
    "\n",
    "            if lista_tabu.existe(vecino[1]) == False and vecino[2] < coste_act:\n",
    "                s_act = vecino[0]\n",
    "                movimiento_s_act = vecino[1]\n",
    "                coste_act = vecino[2]\n",
    "        if coste_act == float(\"inf\"):\n",
    "            #No hay soluciones mejores, no entiendo bien esto la verdad........\n",
    "            print(\"salimos\")\n",
    "            break\n",
    "        if coste_act < funcion_coste(s_mejor, MAPA):\n",
    "            s_mejor = s_act\n",
    "            iteracion = i\n",
    "            its_sin_mejora = 0\n",
    "            lista_mejores_soluciones.add(s_mejor)\n",
    "        #Este else es para añadir la reinicializacion\n",
    "        else:\n",
    "            its_sin_mejora += 1\n",
    "            if its_sin_mejora == 500:\n",
    "                lista_tabu, s_act = reinicializacion(lista_mejores_soluciones, N)\n",
    "                print(lista_tabu, funcion_coste(s_act, MAPA))\n",
    "                its_sin_mejora = 0\n",
    "                continue\n",
    "            \n",
    "        \n",
    "        lista_tabu.add(movimiento_s_act)\n",
    "        \n",
    "        if i % 500 == 0:\n",
    "            print(funcion_coste(s_mejor, MAPA), i)\n",
    "        \n",
    "    return (s_mejor, iteracion)\n",
    "\n",
    "def reinicializacion(lista_mejores_soluciones, N):\n",
    "    return (Listatabu(N), lista_mejores_soluciones.primero())\n",
    "    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 183,
   "id": "3456977f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "[] 31526.573744255846\n",
      "30406.55500874364 3000\n",
      "[] 30538.667621488617\n",
      "30406.55500874364 3500\n",
      "[] 30509.491014717925\n",
      "30406.55500874364 4000\n",
      "[] 30481.604651706893\n",
      "30406.55500874364 4500\n",
      "[] 30462.15493654984\n",
      "30406.55500874364 5000\n",
      "[] 30437.63612612357\n",
      "30406.55500874364 5500\n",
      "[] 30425.82411737802\n",
      "30406.55500874364 6000\n",
      "[] 30418.76728871292\n",
      "30406.55500874364 6500\n",
      "[] 30416.447085097734\n",
      "30406.55500874364 7000\n",
      "[] 30409.133080221578\n",
      "30331.40667988796 7500\n",
      "[] 30406.55500874364\n",
      "30331.40667988796 8000\n",
      "[] 30387.294393481134\n",
      "30331.40667988796 8500\n",
      "[] 30369.99989460776\n",
      "30331.40667988796 9000\n",
      "[] 30353.05461404052\n",
      "30331.40667988796 9500\n",
      "[] 30337.46273027143\n",
      "Tiempo que ha tardado:  331.9019639492035\n",
      "(11, 41, 23, 52, 117, 92, 34, 9, 111, 20, 116, 29, 39, 76, 102, 44, 30, 45, 6, 57, 97, 48, 85, 95, 31, 65, 93, 28, 3, 53, 50, 59, 16, 35, 94, 18, 66, 99, 98, 19, 72, 54, 112, 87, 5, 118, 15, 67, 12, 115, 106, 1, 61, 56, 7, 47, 60, 49, 70, 73, 88, 104, 33, 108, 46, 96, 103, 17, 25, 27, 86, 21, 55, 64, 74, 37, 84, 2, 83, 69, 82, 71, 42, 4, 36, 105, 40, 38, 8, 32, 43, 90, 100, 68, 22, 107, 114, 80, 78, 77, 10, 101, 79, 51, 91, 81, 109, 13, 110, 113, 26, 24, 63, 75, 62, 58, 14, 89, 119) 7129\n",
      "coste 30331.40667988796\n"
     ]
    }
   ],
   "source": [
    "#Probamos el cambio en la reinicialización\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, 10, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3a06f2e8",
   "metadata": {},
   "outputs": [],
   "source": [
    "#UTILIZANDO UNA PILA EN VEZ DE UNA COLA\n",
    "class Listatabu:\n",
    "    def __init__(self, max_items):\n",
    "        self.max_items = max_items\n",
    "        self.elementos_lista = []\n",
    "        self.num_elems = len(self.elementos_lista)\n",
    "        self.elementos_set = set()\n",
    "        \n",
    "    def add(self, elemento):\n",
    "        if self.num_elems == self.max_items:\n",
    "            eliminado = self.elementos_lista.pop(0)\n",
    "            self.elementos_lista.append(elemento)\n",
    "            self.elementos_set.remove(eliminado)\n",
    "            self.elementos_set.add(elemento)\n",
    "        else:\n",
    "            self.elementos_lista.append(elemento)\n",
    "            self.elementos_set.add(elemento)\n",
    "            self.num_elems += 1\n",
    "            \n",
    "    def primero(self):\n",
    "        eliminado = self.elementos_lista.pop(len(self.elementos_lista)-1)\n",
    "        self.elementos_set.remove(eliminado)\n",
    "        self.num_elems -= 1\n",
    "        return eliminado\n",
    "            \n",
    "    def existe(self, elemento):\n",
    "        if elemento in self.elementos_set:\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "        \n",
    "    def __str__(self):\n",
    "        return str(self.elementos_lista)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 187,
   "id": "f84ea3da",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "31038.203114984102 3000\n",
      "[] 31177.775292093786\n",
      "30416.447085097734 3500\n",
      "30350.181571637146 4000\n",
      "29867.88636182958 4500\n",
      "29755.47252785513 5000\n",
      "29755.47252785513 5500\n",
      "29565.45036669851 6000\n",
      "29565.45036669851 6500\n",
      "[] 29640.59900514007\n",
      "29129.00522434549 7000\n",
      "29129.00522434549 7500\n",
      "[] 29241.662565235318\n",
      "29129.00522434549 8000\n",
      "29129.00522434549 8500\n",
      "[] 29234.605736570218\n",
      "29129.00522434549 9000\n",
      "29129.00522434549 9500\n",
      "[] 29221.055941841954\n",
      "Tiempo que ha tardado:  334.82553696632385\n",
      "(113, 26, 23, 52, 117, 92, 34, 9, 111, 20, 116, 29, 39, 76, 102, 44, 30, 45, 6, 57, 97, 48, 108, 33, 85, 95, 28, 3, 66, 18, 16, 59, 4, 36, 35, 94, 99, 98, 19, 31, 72, 54, 112, 87, 5, 118, 15, 67, 12, 115, 106, 1, 61, 56, 7, 47, 60, 49, 25, 17, 103, 96, 46, 104, 88, 73, 70, 86, 27, 65, 93, 21, 55, 53, 50, 64, 74, 42, 105, 71, 40, 38, 8, 89, 119, 109, 81, 91, 77, 114, 107, 10, 101, 79, 51, 32, 43, 90, 100, 68, 22, 80, 78, 13, 83, 69, 82, 84, 37, 14, 11, 63, 24, 41, 75, 62, 58, 110, 2) 9984\n",
      "coste 29126.15173167695\n"
     ]
    }
   ],
   "source": [
    "#Probaremos ahora con la implementacion en forma de pila y reinicializacion cada 1000 iteraciones\n",
    "#Probamos el cambio en la reinicialización\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, 5, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 190,
   "id": "877494f1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "[] 31526.573744255846\n",
      "30406.55500874364 3000\n",
      "[] 30538.667621488617\n",
      "30406.55500874364 3500\n",
      "[] 30509.491014717925\n",
      "30406.55500874364 4000\n",
      "[] 30481.604651706893\n",
      "30406.55500874364 4500\n",
      "[] 30462.15493654984\n",
      "30406.55500874364 5000\n",
      "[] 30437.63612612357\n",
      "30406.55500874364 5500\n",
      "[] 30425.82411737802\n",
      "30406.55500874364 6000\n",
      "[] 30418.76728871292\n",
      "30406.55500874364 6500\n",
      "[] 30416.447085097734\n",
      "30406.55500874364 7000\n",
      "[] 30409.133080221578\n",
      "30331.40667988796 7500\n",
      "[] 30406.55500874364\n",
      "30331.40667988796 8000\n",
      "[] 30387.294393481134\n",
      "30331.40667988796 8500\n",
      "[] 30369.99989460776\n",
      "30331.40667988796 9000\n",
      "[] 30353.05461404052\n",
      "30331.40667988796 9500\n",
      "[] 30337.46273027143\n",
      "Tiempo que ha tardado:  323.78691697120667\n",
      "(11, 41, 23, 52, 117, 92, 34, 9, 111, 20, 116, 29, 39, 76, 102, 44, 30, 45, 6, 57, 97, 48, 85, 95, 31, 65, 93, 28, 3, 53, 50, 59, 16, 35, 94, 18, 66, 99, 98, 19, 72, 54, 112, 87, 5, 118, 15, 67, 12, 115, 106, 1, 61, 56, 7, 47, 60, 49, 70, 73, 88, 104, 33, 108, 46, 96, 103, 17, 25, 27, 86, 21, 55, 64, 74, 37, 84, 2, 83, 69, 82, 71, 42, 4, 36, 105, 40, 38, 8, 32, 43, 90, 100, 68, 22, 107, 114, 80, 78, 77, 10, 101, 79, 51, 91, 81, 109, 13, 110, 113, 26, 24, 63, 75, 62, 58, 14, 89, 119) 7129\n",
      "coste 30331.40667988796\n"
     ]
    }
   ],
   "source": [
    "#Probaremos ahora con la implementacion en forma de pila y reinicializacion cada 500 iteraciones\n",
    "#Probamos el cambio en la reinicialización\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, 10, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8898511a",
   "metadata": {},
   "source": [
    "<h3> Utilizar la estrategia de reinicialización de diversificación a través de una matriz de frecuencias. Reinicializar en una solución igual a la mejora de inicialización greedy, pero teniendo en cuenta un sobrecoste ficticio que aumenta el coste de la distancia entre dos ciudades si su frecuencia es mayor. </h3>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 326,
   "id": "a8e07b44",
   "metadata": {},
   "outputs": [],
   "source": [
    "def actualiza_frecuencias(matriz, s_act):\n",
    "    for i in range(len(s_act)-1):\n",
    "\n",
    "        matriz[s_act[i]][s_act[i+1]] += 1\n",
    "            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 327,
   "id": "a706d48f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def busqueda_tabu(MAPA, NUM_CIUDADES, N, MAX_ITS, inicial = []):\n",
    "    if len(inicial)==0:\n",
    "        s_in = genera_solucion_inicial(MAPA)\n",
    "    else:\n",
    "        s_in = inicial\n",
    "    print(\"sin : \", s_in)\n",
    "    s_mejor = s_in\n",
    "    s_act = s_in\n",
    "    lista_tabu = Listatabu(N) #No añadimos nada porque no se ha hecho ningun movimiento todavia\n",
    "    \n",
    "    matriz = [[0 for _ in range(NUM_CIUDADES)] for _ in range(NUM_CIUDADES)]\n",
    "    \n",
    "    its_sin_mejora = 0\n",
    "    \n",
    "    for i in range(MAX_ITS):\n",
    "        vecinos = genera_vecindario(s_act)\n",
    "        #Ahora calcularemos el coste de todos los vecinos y lo haremos parte de la tupla (vecino, movimiento, coste)\n",
    "        vecinos = coste_vecinos(s_act, vecinos, MAPA)\n",
    "        coste_act = float(\"inf\")\n",
    "        for vecino in vecinos:\n",
    "\n",
    "            if lista_tabu.existe(vecino[1]) == False and vecino[2] < coste_act:\n",
    "                s_act = vecino[0]\n",
    "                movimiento_s_act = vecino[1]\n",
    "                coste_act = vecino[2] \n",
    "        \n",
    "        actualiza_frecuencias(matriz, s_act)\n",
    "        \n",
    "        if coste_act == float(\"inf\"):\n",
    "            #No hay soluciones mejores, no entiendo bien esto la verdad........\n",
    "            print(\"salimos\")\n",
    "            break\n",
    "        if coste_act < funcion_coste(s_mejor, MAPA):\n",
    "            s_mejor = s_act\n",
    "            iteracion = i\n",
    "            its_sin_mejora = 0\n",
    "        #Este else es para añadir la reinicializacion\n",
    "        else:\n",
    "            its_sin_mejora += 1\n",
    "            if its_sin_mejora == 1000:\n",
    "                lista_tabu, s_act = reinicializacion(N, MAPA, matriz, i)\n",
    "                print(lista_tabu, funcion_coste(s_act, MAPA))\n",
    "                its_sin_mejora = 0\n",
    "                continue\n",
    "            \n",
    "        \n",
    "        lista_tabu.add(movimiento_s_act)\n",
    "        \n",
    "        if i % 500 == 0:\n",
    "            print(funcion_coste(s_mejor, MAPA), i)\n",
    "        \n",
    "    return (s_mejor, iteracion)\n",
    "\n",
    "def coste_vecinos(s_act, vecinos, mapa):\n",
    "    coste_actual = funcion_coste(s_act, mapa)\n",
    "    for vecino in vecinos:\n",
    "        coste_nuevo = coste_actual\n",
    "        for intercambio in vecino[1]:\n",
    "            if intercambio == 0:\n",
    "                coste_nuevo -= mapa.distancia(0, s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], s_act[intercambio+1])\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(0, vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], vecino[0][intercambio+1])\n",
    "            elif intercambio == len(s_act)-1:\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio-1], s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], 0)\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio-1], vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], 0)\n",
    "            else:\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio-1], s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], s_act[intercambio+1])\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio-1], vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], vecino[0][intercambio+1])\n",
    "                \n",
    "        vecino.append(coste_nuevo)\n",
    "    \n",
    "    return vecinos\n",
    "\n",
    "# funcion de generacion de vencindario\n",
    "def genera_vecindario(s_act):\n",
    "    vecindario = []\n",
    "    for i in range(len(s_act)):\n",
    "        for j in range(i+1,len(s_act)):\n",
    "            vecino = list(s_act)\n",
    "            vecino[i], vecino[j] = vecino[j], vecino[i]\n",
    "            vecindario.append([tuple(vecino),(i,j)])\n",
    "    \n",
    "    return vecindario"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 328,
   "id": "c27d6115",
   "metadata": {},
   "outputs": [],
   "source": [
    "def genera_solucion_reinicializacion(mapa, matriz, iteraciones):\n",
    "    solucion = [0]\n",
    "    ciudades_restantes = [i for i in range(1,mapa.nciudades)]\n",
    "    while len(ciudades_restantes)!=0:\n",
    "        ciudad_actual = solucion[-1]\n",
    "        menor_coste = float(\"inf\")\n",
    "        for ciudad in ciudades_restantes:\n",
    "            coste = mapa.distancia(ciudad_actual, ciudad) + 0.3 * ((4519.928067703717 - 2.1459403220087387) * (matriz[ciudad_actual][ciudad]/iteraciones))\n",
    "            if coste < menor_coste:\n",
    "                menor_coste = coste\n",
    "                ciudad_mas_cercana = ciudad\n",
    "        \n",
    "        solucion.append(ciudad_mas_cercana)\n",
    "        ciudades_restantes.remove(ciudad_mas_cercana)\n",
    "        \n",
    "    solucion.pop(0)\n",
    "    return solucion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 329,
   "id": "382a952a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def reinicializacion(N, mapa, matriz, iteraciones):\n",
    "    return (Listatabu(N), genera_solucion_reinicializacion(mapa, matriz, iteraciones))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 219,
   "id": "2054cce6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "31038.203114984102 3000\n",
      "[] 36795.007828372756\n",
      "27758.30570539518 3500\n",
      "27431.3721488721 4000\n",
      "27186.306283192076 4500\n",
      "27070.3778525235 5000\n",
      "27063.130355748774 5500\n",
      "26437.138681446097 6000\n",
      "26406.790942778418 6500\n",
      "26242.369310959515 7000\n",
      "26241.50913862709 7500\n",
      "26036.182187500624 8000\n",
      "26036.182187500624 8500\n",
      "[] 40217.043191566176\n",
      "26036.182187500624 9000\n",
      "26036.182187500624 9500\n",
      "[] 41391.590422370566\n",
      "Tiempo que ha tardado:  332.92052602767944\n",
      "(78, 80, 77, 101, 10, 79, 51, 91, 81, 109, 119, 89, 82, 84, 37, 74, 42, 36, 16, 18, 59, 4, 50, 64, 58, 11, 26, 24, 63, 41, 75, 28, 93, 65, 27, 86, 47, 60, 34, 92, 23, 52, 117, 17, 103, 96, 73, 88, 70, 25, 49, 9, 111, 20, 19, 7, 56, 99, 98, 94, 35, 105, 38, 40, 8, 32, 43, 90, 100, 68, 22, 114, 107, 13, 83, 69, 2, 110, 113, 14, 62, 55, 21, 53, 3, 61, 1, 106, 115, 12, 67, 15, 118, 5, 72, 85, 95, 112, 54, 87, 116, 29, 39, 76, 44, 102, 30, 45, 6, 57, 97, 48, 108, 33, 46, 104, 31, 66, 71) 7792\n",
      "coste 26036.182187500624\n"
     ]
    }
   ],
   "source": [
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 330,
   "id": "42b2165a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def genera_solucion_inicial(mapa):\n",
    "    solucion = [0]\n",
    "    ciudades_restantes = [i for i in range(1,mapa.nciudades)]\n",
    "    while len(ciudades_restantes)!=0:\n",
    "        ciudad_actual = solucion[-1]\n",
    "        menor_coste = float(\"inf\")\n",
    "        for ciudad in ciudades_restantes:\n",
    "            coste = mapa.distancia(ciudad_actual, ciudad)\n",
    "            if coste < menor_coste:\n",
    "                menor_coste = coste\n",
    "                ciudad_mas_cercana = ciudad\n",
    "        \n",
    "        solucion.append(ciudad_mas_cercana)\n",
    "        ciudades_restantes.remove(ciudad_mas_cercana)\n",
    "        \n",
    "    solucion.pop(0)\n",
    "    return solucion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 240,
   "id": "ef82c73b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "HOLA\n",
      "sin :  [91, 81, 109, 119, 89, 8, 40, 38, 105, 36, 42, 4, 59, 16, 35, 94, 18, 66, 3, 53, 50, 64, 74, 37, 84, 2, 69, 83, 82, 13, 78, 80, 114, 107, 77, 10, 101, 79, 51, 22, 68, 90, 100, 43, 32, 71, 110, 113, 14, 58, 11, 62, 75, 63, 41, 24, 21, 55, 28, 93, 65, 27, 86, 47, 60, 9, 111, 20, 49, 25, 17, 92, 34, 117, 52, 23, 103, 96, 70, 73, 88, 31, 72, 54, 112, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 102, 44, 76, 39, 29, 116, 87, 5, 118, 15, 67, 12, 61, 115, 106, 1, 98, 99, 56, 7, 19, 104, 46, 26]\n",
      "26848.657520994584 0\n",
      "26302.46268665838 500\n",
      "26302.46268665838 1000\n",
      "[] 34176.82272868777\n",
      "26302.46268665838 1500\n",
      "26302.46268665838 2000\n",
      "[] 39592.88472325353\n",
      "26302.46268665838 2500\n",
      "26302.46268665838 3000\n",
      "[] 37473.60742188864\n",
      "26302.46268665838 3500\n",
      "26302.46268665838 4000\n",
      "[] 42116.631868404664\n",
      "26302.46268665838 4500\n",
      "26302.46268665838 5000\n",
      "[] 41100.27899761876\n",
      "26302.46268665838 5500\n",
      "26302.46268665838 6000\n",
      "[] 37738.632847440036\n",
      "26302.46268665838 6500\n",
      "26302.46268665838 7000\n",
      "[] 40101.38193297603\n",
      "26302.46268665838 7500\n",
      "26302.46268665838 8000\n",
      "[] 40350.482248967455\n",
      "26302.46268665838 8500\n",
      "26302.46268665838 9000\n",
      "[] 39818.88249766526\n",
      "26302.46268665838 9500\n",
      "Tiempo que ha tardado:  333.5565366744995\n",
      "(81, 91, 109, 119, 89, 8, 40, 38, 71, 42, 105, 36, 4, 35, 18, 59, 16, 66, 3, 53, 50, 64, 74, 37, 84, 69, 82, 83, 13, 78, 80, 107, 114, 90, 100, 68, 22, 32, 43, 79, 51, 10, 101, 77, 2, 110, 113, 14, 58, 11, 26, 24, 41, 63, 75, 62, 55, 21, 28, 93, 65, 27, 86, 47, 60, 20, 111, 9, 49, 25, 17, 34, 92, 23, 52, 117, 103, 96, 70, 73, 88, 31, 72, 54, 112, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 102, 44, 76, 39, 29, 116, 87, 5, 118, 15, 67, 12, 115, 106, 1, 61, 98, 99, 56, 7, 19, 46, 104, 94) 361\n",
      "coste 26302.46268665838\n"
     ]
    }
   ],
   "source": [
    "#Ahora vamos a probar esto acompañado de la inicialización de la solución greedy\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1852a7eb",
   "metadata": {},
   "source": [
    "<h3> Oscilación estratégica de los mecanismos de reinicialización (diversificación e intensificación), eligiendo uno u otro aleatoriamente. Ajustado de los parámetros Mu y número de iteraciones sin mejora para reinicialización </h3>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 331,
   "id": "4bb8d4c4",
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "def reinicializacion(N, mapa, matriz, iteraciones, s_mejor):\n",
    "    random.uniform(0,1)\n",
    "    if random.uniform(0,1) > 0.5:\n",
    "        print(\"diversificacion\")\n",
    "        return (Listatabu(N), genera_solucion_reinicializacion(mapa, matriz, iteraciones))\n",
    "    else:\n",
    "        print(\"intensificacion\")\n",
    "        return (Listatabu(N), s_mejor)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 337,
   "id": "acd81990",
   "metadata": {},
   "outputs": [],
   "source": [
    "def busqueda_tabu(MAPA, NUM_CIUDADES, N, MAX_ITS, inicial = []):\n",
    "    if len(inicial)==0:\n",
    "        s_in = genera_solucion_inicial(MAPA)\n",
    "    else:\n",
    "        s_in = inicial\n",
    "    print(\"sin : \", s_in)\n",
    "    s_mejor = s_in\n",
    "    s_act = s_in\n",
    "    lista_tabu = Listatabu(N) #No añadimos nada porque no se ha hecho ningun movimiento todavia\n",
    "    \n",
    "    matriz = [[0 for _ in range(NUM_CIUDADES)] for _ in range(NUM_CIUDADES)]\n",
    "    \n",
    "    its_sin_mejora = 0\n",
    "    \n",
    "    for i in range(MAX_ITS):\n",
    "        vecinos = genera_vecindario(s_act)\n",
    "        #Ahora calcularemos el coste de todos los vecinos y lo haremos parte de la tupla (vecino, movimiento, coste)\n",
    "        vecinos = coste_vecinos(s_act, vecinos, MAPA)\n",
    "        coste_act = float(\"inf\")\n",
    "        for vecino in vecinos:\n",
    "\n",
    "            if lista_tabu.existe(vecino[1]) == False and vecino[2] < coste_act:\n",
    "                s_act = vecino[0]\n",
    "                movimiento_s_act = vecino[1]\n",
    "                coste_act = vecino[2] #HACE FALTA ESTAR CALCULANDO ESTO TODO EL RATO????\n",
    "        \n",
    "        actualiza_frecuencias(matriz, s_act)\n",
    "\n",
    "        \n",
    "        \n",
    "        if coste_act == float(\"inf\"):\n",
    "            #No hay soluciones mejores, no entiendo bien esto la verdad........\n",
    "            print(\"salimos\")\n",
    "            break\n",
    "        if coste_act < funcion_coste(s_mejor, MAPA):\n",
    "            s_mejor = s_act\n",
    "            iteracion = i\n",
    "            its_sin_mejora = 0\n",
    "        else:\n",
    "            its_sin_mejora += 1\n",
    "            if its_sin_mejora == 500:\n",
    "                lista_tabu, s_act = reinicializacion(N, MAPA, matriz, i, s_mejor)\n",
    "                print(lista_tabu, funcion_coste(s_act, MAPA))\n",
    "                its_sin_mejora = 0\n",
    "                continue\n",
    "            \n",
    "        \n",
    "        lista_tabu.add(movimiento_s_act)\n",
    "        \n",
    "        if i % 500 == 0:\n",
    "            print(funcion_coste(s_mejor, MAPA), i)\n",
    "        \n",
    "    return (s_mejor, iteracion)\n",
    "\n",
    "def coste_vecinos(s_act, vecinos, mapa):\n",
    "    coste_actual = funcion_coste(s_act, mapa)\n",
    "    for vecino in vecinos:\n",
    "        coste_nuevo = coste_actual\n",
    "        for intercambio in vecino[1]:\n",
    "            if intercambio == 0:\n",
    "                coste_nuevo -= mapa.distancia(0, s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], s_act[intercambio+1])\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(0, vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], vecino[0][intercambio+1])\n",
    "            elif intercambio == len(s_act)-1:\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio-1], s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], 0)\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio-1], vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], 0)\n",
    "            else:\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio-1], s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], s_act[intercambio+1])\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio-1], vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], vecino[0][intercambio+1])\n",
    "                \n",
    "        vecino.append(coste_nuevo)\n",
    "    \n",
    "    return vecinos\n",
    "\n",
    "# funcion de generacion de vencindario\n",
    "def genera_vecindario(s_act):\n",
    "    vecindario = []\n",
    "    for i in range(len(s_act)):\n",
    "        for j in range(i+1,len(s_act)):\n",
    "            vecino = list(s_act)\n",
    "            vecino[i], vecino[j] = vecino[j], vecino[i]\n",
    "            vecindario.append([tuple(vecino),(i,j)])\n",
    "    \n",
    "    return vecindario"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 269,
   "id": "40c14475",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "intensificacion\n",
      "[] 31038.203114984102\n",
      "30329.548030619946 3000\n",
      "diversificacion\n",
      "[] 36332.595065570466\n",
      "27117.980388460495 3500\n",
      "26854.40777782181 4000\n",
      "26572.99172196797 4500\n",
      "diversificacion\n",
      "[] 38522.392457039095\n",
      "26572.99172196797 5000\n",
      "diversificacion\n",
      "[] 36974.34628318237\n",
      "26572.99172196797 5500\n",
      "diversificacion\n",
      "[] 38488.87333853192\n",
      "26572.99172196797 6000\n",
      "diversificacion\n",
      "[] 39521.75768767092\n",
      "25498.789543819898 6500\n",
      "diversificacion\n",
      "[] 41813.34047428527\n",
      "25498.789543819898 7000\n",
      "intensificacion\n",
      "[] 25498.789543819898\n",
      "25061.94052863341 7500\n",
      "intensificacion\n",
      "[] 25061.94052863341\n",
      "25061.94052863341 8000\n",
      "intensificacion\n",
      "[] 25061.94052863341\n",
      "25061.94052863341 8500\n",
      "diversificacion\n",
      "[] 40954.69874069019\n",
      "25061.94052863341 9000\n",
      "diversificacion\n",
      "[] 40301.957554709006\n",
      "25061.94052863341 9500\n",
      "diversificacion\n",
      "[] 40567.004973663505\n",
      "Tiempo que ha tardado:  331.01924538612366\n",
      "(78, 80, 114, 107, 77, 10, 101, 79, 51, 91, 81, 109, 119, 8, 89, 13, 83, 69, 82, 2, 84, 37, 74, 64, 50, 53, 18, 16, 59, 35, 4, 36, 42, 71, 110, 113, 14, 11, 26, 24, 41, 63, 75, 62, 58, 55, 21, 3, 28, 93, 65, 27, 86, 47, 60, 7, 56, 99, 98, 61, 1, 106, 115, 118, 15, 67, 12, 19, 20, 111, 9, 49, 25, 34, 92, 23, 52, 117, 17, 103, 96, 70, 73, 88, 31, 72, 87, 112, 54, 95, 85, 104, 46, 33, 108, 48, 97, 57, 6, 45, 30, 44, 102, 76, 39, 29, 116, 5, 66, 94, 105, 40, 38, 32, 43, 90, 100, 68, 22) 7295\n",
      "coste 25061.94052863341\n"
     ]
    }
   ],
   "source": [
    "#Mu = 0.3\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 336,
   "id": "ff5bd4b0",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Ahora probaremos con mu = 0.05\n",
    "def genera_solucion_reinicializacion(mapa, matriz, iteraciones):\n",
    "    solucion = [0]\n",
    "    ciudades_restantes = [i for i in range(1,mapa.nciudades)]\n",
    "    while len(ciudades_restantes)!=0:\n",
    "        ciudad_actual = solucion[-1]\n",
    "        menor_coste = float(\"inf\")\n",
    "        for ciudad in ciudades_restantes:\n",
    "            coste = mapa.distancia(ciudad_actual, ciudad) + 0.05 * ((4519.928067703717 - 2.1459403220087387) * (matriz[ciudad_actual][ciudad]/iteraciones))\n",
    "            if coste < menor_coste:\n",
    "                menor_coste = coste\n",
    "                ciudad_mas_cercana = ciudad\n",
    "        \n",
    "        solucion.append(ciudad_mas_cercana)\n",
    "        ciudades_restantes.remove(ciudad_mas_cercana)\n",
    "        \n",
    "    solucion.pop(0)\n",
    "    return solucion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 305,
   "id": "de9f1fe1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "intensificacion\n",
      "[] 31038.203114984102\n",
      "30329.548030619946 3000\n",
      "intensificacion\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 3500\n",
      "intensificacion\n",
      "[] 30329.548030619946\n",
      "30329.548030619946 4000\n",
      "diversificacion\n",
      "[] 30203.6651242509\n",
      "27917.425991495216 4500\n",
      "27660.712709573403 5000\n",
      "intensificacion\n",
      "[] 27660.712709573403\n",
      "27136.081412207965 5500\n",
      "intensificacion\n",
      "[] 27136.081412207965\n",
      "27133.79455078112 6000\n",
      "intensificacion\n",
      "[] 27133.79455078112\n",
      "27133.79455078112 6500\n",
      "intensificacion\n",
      "[] 27133.79455078112\n",
      "27133.79455078112 7000\n",
      "intensificacion\n",
      "[] 27133.79455078112\n",
      "27133.79455078112 7500\n",
      "diversificacion\n",
      "[] 30808.219128107976\n",
      "27133.79455078112 8000\n",
      "intensificacion\n",
      "[] 27133.79455078112\n",
      "27133.79455078112 8500\n",
      "diversificacion\n",
      "[] 27912.120449766815\n",
      "25878.50939251162 9000\n",
      "diversificacion\n",
      "[] 28777.62468424482\n",
      "25878.50939251162 9500\n",
      "diversificacion\n",
      "[] 30799.973447355027\n",
      "Tiempo que ha tardado:  326.830445766449\n",
      "(81, 109, 91, 78, 80, 107, 114, 77, 101, 51, 79, 10, 22, 68, 100, 90, 43, 32, 119, 13, 83, 69, 82, 84, 37, 71, 89, 8, 38, 40, 105, 36, 42, 4, 16, 59, 35, 94, 18, 66, 3, 53, 50, 64, 74, 14, 11, 58, 62, 55, 21, 75, 63, 24, 41, 23, 52, 117, 92, 34, 49, 25, 17, 103, 96, 88, 73, 70, 111, 9, 60, 47, 27, 86, 65, 93, 28, 7, 56, 99, 98, 1, 61, 67, 15, 118, 5, 87, 72, 54, 112, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 44, 102, 76, 39, 29, 116, 106, 115, 12, 19, 20, 31, 104, 46, 26, 113, 110, 2) 8829\n",
      "coste 25878.50939251162\n"
     ]
    }
   ],
   "source": [
    "#Ahora probamos con una solución inicial normal, con u=0.05\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 293,
   "id": "aa49ff15",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Prueba con número de iteraciones sin mejora = 250\n",
    "def busqueda_tabu(MAPA, NUM_CIUDADES, N, MAX_ITS, inicial = []):\n",
    "    if len(inicial)==0:\n",
    "        s_in = genera_solucion_inicial(MAPA)\n",
    "    else:\n",
    "        s_in = inicial\n",
    "    print(\"sin : \", s_in)\n",
    "    s_mejor = s_in\n",
    "    s_act = s_in\n",
    "    lista_tabu = Listatabu(N) #No añadimos nada porque no se ha hecho ningun movimiento todavia\n",
    "    \n",
    "    matriz = [[0 for _ in range(NUM_CIUDADES)] for _ in range(NUM_CIUDADES)]\n",
    "    \n",
    "    its_sin_mejora = 0\n",
    "    \n",
    "    for i in range(MAX_ITS):\n",
    "        vecinos = genera_vecindario(s_act)\n",
    "        #Ahora calcularemos el coste de todos los vecinos y lo haremos parte de la tupla (vecino, movimiento, coste)\n",
    "        vecinos = coste_vecinos(s_act, vecinos, MAPA)\n",
    "        coste_act = float(\"inf\")\n",
    "        for vecino in vecinos:\n",
    "            if lista_tabu.existe(vecino[1]) == False and vecino[2] < coste_act:\n",
    "                s_act = vecino[0]\n",
    "                movimiento_s_act = vecino[1]\n",
    "                coste_act = vecino[2] \n",
    "        \n",
    "        actualiza_frecuencias(matriz, s_act)\n",
    "\n",
    "        \n",
    "        \n",
    "        if coste_act == float(\"inf\"):\n",
    "            #No hay soluciones mejores, no entiendo bien esto la verdad........\n",
    "            print(\"salimos\")\n",
    "            break\n",
    "        if coste_act < funcion_coste(s_mejor, MAPA):\n",
    "            s_mejor = s_act\n",
    "            iteracion = i\n",
    "            its_sin_mejora = 0\n",
    "        #Este else es para añadir la reinicializacion\n",
    "        else:\n",
    "            its_sin_mejora += 1\n",
    "            if its_sin_mejora == 250:\n",
    "                lista_tabu, s_act = reinicializacion(N, MAPA, matriz, i, s_mejor)\n",
    "                print(lista_tabu, funcion_coste(s_act, MAPA))\n",
    "                its_sin_mejora = 0\n",
    "                continue\n",
    "            \n",
    "        \n",
    "        lista_tabu.add(movimiento_s_act)\n",
    "        \n",
    "        if i % 500 == 0:\n",
    "            print(funcion_coste(s_mejor, MAPA), i)\n",
    "        \n",
    "    return (s_mejor, iteracion)\n",
    "\n",
    "def coste_vecinos(s_act, vecinos, mapa):\n",
    "    coste_actual = funcion_coste(s_act, mapa)\n",
    "    for vecino in vecinos:\n",
    "        coste_nuevo = coste_actual\n",
    "        for intercambio in vecino[1]:\n",
    "            if intercambio == 0:\n",
    "                coste_nuevo -= mapa.distancia(0, s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], s_act[intercambio+1])\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(0, vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], vecino[0][intercambio+1])\n",
    "            elif intercambio == len(s_act)-1:\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio-1], s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], 0)\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio-1], vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], 0)\n",
    "            else:\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio-1], s_act[intercambio])\n",
    "                coste_nuevo -= mapa.distancia(s_act[intercambio], s_act[intercambio+1])\n",
    "                \n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio-1], vecino[0][intercambio])\n",
    "                coste_nuevo += mapa.distancia(vecino[0][intercambio], vecino[0][intercambio+1])\n",
    "                \n",
    "        vecino.append(coste_nuevo)\n",
    "    \n",
    "    return vecinos\n",
    "\n",
    "# funcion de generacion de vencindario\n",
    "def genera_vecindario(s_act):\n",
    "    vecindario = []\n",
    "    for i in range(len(s_act)):\n",
    "        for j in range(i+1,len(s_act)):\n",
    "            vecino = list(s_act)\n",
    "            vecino[i], vecino[j] = vecino[j], vecino[i]\n",
    "            vecindario.append([tuple(vecino),(i,j)])\n",
    "    \n",
    "    return vecindario"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 294,
   "id": "880d3e3a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "diversificacion\n",
      "[] 28434.645749076477\n",
      "26883.498260799333 1000\n",
      "intensificacion\n",
      "[] 26785.85576725712\n",
      "26545.294919373708 1500\n",
      "intensificacion\n",
      "[] 26545.294919373708\n",
      "diversificacion\n",
      "[] 31060.259543576733\n",
      "26545.294919373708 2000\n",
      "intensificacion\n",
      "[] 26545.294919373708\n",
      "intensificacion\n",
      "[] 26545.294919373708\n",
      "26545.294919373708 2500\n",
      "diversificacion\n",
      "[] 29856.548429402148\n",
      "diversificacion\n",
      "[] 31626.83719108861\n",
      "26545.294919373708 3000\n",
      "intensificacion\n",
      "[] 26545.294919373708\n",
      "intensificacion\n",
      "[] 26545.294919373708\n",
      "26545.294919373708 3500\n",
      "diversificacion\n",
      "[] 30418.399992067083\n",
      "26083.99019868954 4000\n",
      "intensificacion\n",
      "[] 26083.99019868954\n",
      "intensificacion\n",
      "[] 25520.332669033593\n",
      "25433.724538854185 4500\n",
      "diversificacion\n",
      "[] 31879.315467302407\n",
      "25395.563650106 5000\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "25395.563650106 5500\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "diversificacion\n",
      "[] 31206.26188821154\n",
      "25395.563650106 6000\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "diversificacion\n",
      "[] 28551.700328856055\n",
      "25395.563650106 6500\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "25395.563650106 7000\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "diversificacion\n",
      "[] 31240.30453114689\n",
      "25395.563650106 7500\n",
      "diversificacion\n",
      "[] 32027.421654896043\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "25395.563650106 8000\n",
      "diversificacion\n",
      "[] 31806.075418250188\n",
      "diversificacion\n",
      "[] 31007.442099728192\n",
      "25395.563650106 8500\n",
      "diversificacion\n",
      "[] 31690.8347613253\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "25395.563650106 9000\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "25395.563650106 9500\n",
      "intensificacion\n",
      "[] 25395.563650106\n",
      "diversificacion\n",
      "[] 30260.05718550158\n",
      "Tiempo que ha tardado:  323.2691910266876\n",
      "(78, 80, 77, 91, 119, 89, 8, 38, 40, 71, 105, 36, 35, 94, 18, 16, 59, 4, 42, 74, 37, 84, 82, 2, 110, 113, 14, 58, 11, 26, 24, 41, 63, 75, 62, 21, 55, 64, 50, 53, 3, 28, 93, 65, 27, 86, 47, 60, 9, 111, 49, 34, 92, 23, 52, 117, 17, 25, 103, 96, 88, 73, 70, 20, 7, 56, 66, 99, 98, 61, 1, 106, 115, 12, 67, 15, 118, 19, 31, 72, 5, 87, 112, 54, 95, 85, 104, 46, 33, 108, 48, 97, 57, 6, 45, 30, 44, 102, 76, 39, 29, 116, 32, 43, 90, 100, 68, 22, 114, 107, 10, 101, 79, 51, 81, 109, 69, 83, 13) 4506\n",
      "coste 25395.563650106\n"
     ]
    }
   ],
   "source": [
    "#Ahora probamos con una solución inicial normal, probamos a reinicializar cada 250 segundos:\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 350,
   "id": "ef2f0018",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
      "179952.61643276052 0\n",
      "35064.48878513802 500\n",
      "33652.78560918093 1000\n",
      "32552.168272584076 1500\n",
      "31875.576217239708 2000\n",
      "31038.203114984102 2500\n",
      "diversificacion\n",
      "[] 29279.718314316415\n",
      "27659.33834708519 3000\n",
      "intensificacion\n",
      "[] 27659.33834708519\n",
      "27659.33834708519 3500\n",
      "intensificacion\n",
      "[] 27659.33834708519\n",
      "27659.33834708519 4000\n",
      "diversificacion\n",
      "[] 27604.797357366922\n",
      "26060.275962112202 4500\n",
      "intensificacion\n",
      "[] 26060.275962112202\n",
      "26023.071303925935 5000\n",
      "diversificacion\n",
      "[] 28647.107813713363\n",
      "26023.071303925935 5500\n",
      "diversificacion\n",
      "[] 28799.919000535512\n",
      "26023.071303925935 6000\n",
      "diversificacion\n",
      "[] 28868.1772095209\n",
      "25945.564535663325 6500\n",
      "diversificacion\n",
      "[] 30029.35166162643\n",
      "25945.564535663325 7000\n",
      "diversificacion\n",
      "[] 29440.36382876794\n",
      "25857.969504331086 7500\n",
      "intensificacion\n",
      "[] 25857.969504331086\n",
      "25690.301717828435 8000\n",
      "intensificacion\n",
      "[] 25690.301717828435\n",
      "25690.301717828435 8500\n",
      "intensificacion\n",
      "[] 25690.301717828435\n",
      "25690.301717828435 9000\n",
      "intensificacion\n",
      "[] 25690.301717828435\n",
      "25690.301717828435 9500\n",
      "intensificacion\n",
      "[] 25690.301717828435\n",
      "Tiempo que ha tardado:  338.1903500556946\n",
      "(78, 91, 81, 109, 119, 89, 82, 69, 83, 2, 84, 37, 74, 64, 50, 4, 59, 16, 18, 94, 35, 36, 42, 105, 40, 38, 8, 51, 79, 101, 10, 77, 80, 114, 107, 22, 68, 100, 90, 43, 32, 13, 110, 113, 14, 11, 58, 62, 75, 63, 26, 24, 41, 21, 55, 53, 3, 28, 93, 65, 86, 27, 7, 56, 99, 98, 1, 61, 67, 15, 118, 5, 72, 87, 112, 54, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 44, 102, 76, 39, 29, 116, 106, 115, 12, 19, 20, 111, 9, 47, 60, 49, 34, 92, 23, 52, 117, 17, 25, 70, 73, 88, 96, 103, 46, 104, 31, 66, 71) 7768\n",
      "coste 25690.301717828435\n"
     ]
    }
   ],
   "source": [
    "# Mu = 0.05 y iteraciones sin mejora = 500\n",
    "inicial = [92, 114, 19, 103, 96, 94, 34, 112, 51, 82, 104, 80, 38, 9, 71, 72, 6, 7, 45, 57, 79, 3, 1, 50, 113, 16, 44, 43, 108, 42, 32, 95, 77, 74, 48, 84, 18, 30, 60, 87, 31, 116, 35, 118, 61, 86, 41, 56, 89, 106, 76, 90, 4, 117, 55, 78, 39, 63, 8, 99, 52, 46, 5, 67, 33, 21, 93, 20, 65, 2, 36, 28, 81, 62, 11, 110, 59, 40, 54, 91, 29, 100, 49, 111, 70, 14, 85, 101, 88, 17, 64, 107, 119, 73, 69, 66, 27, 102, 10, 25, 47, 23, 75, 98, 97, 15, 109, 68, 83, 37, 115, 24, 105, 26, 13, 53, 58, 12, 22]\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000, inicial)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 335,
   "id": "00ddd59b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [91, 81, 109, 119, 89, 8, 40, 38, 105, 36, 42, 4, 59, 16, 35, 94, 18, 66, 3, 53, 50, 64, 74, 37, 84, 2, 69, 83, 82, 13, 78, 80, 114, 107, 77, 10, 101, 79, 51, 22, 68, 90, 100, 43, 32, 71, 110, 113, 14, 58, 11, 62, 75, 63, 41, 24, 21, 55, 28, 93, 65, 27, 86, 47, 60, 9, 111, 20, 49, 25, 17, 92, 34, 117, 52, 23, 103, 96, 70, 73, 88, 31, 72, 54, 112, 95, 85, 33, 108, 48, 97, 57, 6, 45, 30, 102, 44, 76, 39, 29, 116, 87, 5, 118, 15, 67, 12, 61, 115, 106, 1, 98, 99, 56, 7, 19, 104, 46, 26]\n",
      "26848.657520994584 0\n",
      "26302.46268665838 500\n",
      "intensificacion\n",
      "[] 26302.46268665838\n",
      "25637.707278609778 1000\n",
      "diversificacion\n",
      "[] 32666.12814342837\n",
      "25637.707278609778 1500\n",
      "diversificacion\n",
      "[] 29574.848529425457\n",
      "25637.707278609778 2000\n",
      "intensificacion\n",
      "[] 25637.707278609778\n",
      "25619.983016850816 2500\n",
      "intensificacion\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 3000\n",
      "intensificacion\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 3500\n",
      "intensificacion\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 4000\n",
      "intensificacion\n",
      "[] 25619.983016850816\n",
      "25619.983016850816 4500\n",
      "diversificacion\n",
      "[] 29880.50537008552\n",
      "25619.983016850816 5000\n",
      "diversificacion\n",
      "[] 28733.90664491671\n",
      "24749.849373354384 5500\n",
      "24656.98965463895 6000\n",
      "intensificacion\n",
      "[] 24656.98965463895\n",
      "24169.363412152372 6500\n",
      "intensificacion\n",
      "[] 24169.363412152372\n",
      "24169.363412152372 7000\n",
      "diversificacion\n",
      "[] 31293.113518372586\n",
      "24169.363412152372 7500\n",
      "diversificacion\n",
      "[] 30148.123200033162\n",
      "24169.363412152372 8000\n",
      "diversificacion\n",
      "[] 30624.500275647624\n",
      "24169.363412152372 8500\n",
      "intensificacion\n",
      "[] 24169.363412152372\n",
      "24169.363412152372 9000\n",
      "diversificacion\n",
      "[] 29673.513212209968\n",
      "24169.363412152372 9500\n",
      "diversificacion\n",
      "[] 29118.646425710045\n",
      "Tiempo que ha tardado:  333.91382217407227\n",
      "(91, 81, 109, 78, 80, 114, 107, 100, 90, 68, 22, 77, 10, 101, 79, 51, 32, 43, 8, 89, 119, 13, 83, 69, 82, 84, 37, 74, 64, 50, 4, 42, 36, 105, 38, 40, 71, 2, 110, 113, 14, 58, 11, 26, 24, 41, 63, 75, 62, 21, 55, 53, 18, 16, 59, 35, 94, 98, 99, 66, 3, 28, 93, 65, 27, 86, 47, 60, 9, 20, 111, 49, 34, 92, 23, 52, 117, 17, 25, 103, 96, 70, 73, 88, 31, 72, 5, 87, 112, 54, 95, 85, 104, 46, 33, 108, 48, 97, 57, 6, 45, 30, 44, 102, 76, 39, 29, 116, 118, 15, 67, 12, 61, 1, 106, 115, 19, 7, 56) 6258\n",
      "coste 24169.363412152372\n"
     ]
    }
   ],
   "source": [
    "#VAMOS A PROBAR GREEDY CON OSCILACION\n",
    "g5=Localizaciones(filename='./data/US120.txt')\n",
    "inicio = time.time()\n",
    "sol = busqueda_tabu(g5, 120, 100, 10000)\n",
    "fin = time.time()\n",
    "print(\"Tiempo que ha tardado: \", fin-inicio)\n",
    "print(sol[0], sol[1])\n",
    "print(\"coste\", funcion_coste(sol[0], g5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 298,
   "id": "dfe65261",
   "metadata": {},
   "outputs": [],
   "source": [
    "def genera_solucion_inicial(mapa):\n",
    "    lista = [i for i in range(1,mapa.nciudades)]\n",
    "    random.shuffle(lista)\n",
    "    return lista"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 299,
   "id": "f54e6a82",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [73, 105, 48, 55, 106, 41, 119, 104, 53, 6, 101, 21, 45, 56, 99, 91, 36, 75, 93, 17, 2, 57, 46, 103, 12, 35, 10, 52, 79, 80, 31, 70, 64, 8, 118, 83, 88, 110, 22, 72, 96, 7, 87, 44, 29, 50, 58, 117, 38, 84, 95, 68, 90, 82, 51, 59, 108, 69, 5, 14, 43, 61, 34, 85, 115, 18, 49, 113, 23, 71, 97, 74, 86, 109, 66, 89, 81, 76, 111, 4, 1, 25, 65, 11, 13, 37, 9, 15, 100, 62, 60, 107, 16, 94, 40, 102, 116, 47, 98, 26, 67, 92, 78, 63, 33, 112, 24, 114, 42, 20, 28, 32, 30, 54, 77, 3, 27, 19, 39]\n",
      "183976.11141604563 0\n",
      "41555.11784045753 500\n",
      "39399.74160441602 1000\n",
      "39062.47448258463 1500\n",
      "38613.49928678174 2000\n",
      "intensificacion\n",
      "[] 38613.49928678174\n",
      "38434.341469527615 2500\n",
      "intensificacion\n",
      "[] 38434.341469527615\n",
      "38428.759634168004 3000\n",
      "diversificacion\n",
      "[] 28583.40725078996\n",
      "24646.181216447225 3500\n",
      "diversificacion\n",
      "[] 32510.987238547124\n",
      "24646.181216447225 4000\n",
      "diversificacion\n",
      "[] 28485.4538566939\n",
      "24646.181216447225 4500\n",
      "diversificacion\n",
      "[] 32834.274739303044\n",
      "24646.181216447225 5000\n",
      "diversificacion\n",
      "[] 31751.04434182494\n",
      "24646.181216447225 5500\n",
      "diversificacion\n",
      "[] 29158.69794691832\n",
      "24646.181216447225 6000\n",
      "diversificacion\n",
      "[] 31167.648351969336\n",
      "24646.181216447225 6500\n",
      "diversificacion\n",
      "[] 30820.936561592316\n",
      "24646.181216447225 7000\n",
      "diversificacion\n",
      "[] 30818.96150067571\n",
      "24646.181216447225 7500\n",
      "diversificacion\n",
      "[] 32875.26082999211\n",
      "24646.181216447225 8000\n",
      "intensificacion\n",
      "[] 24646.181216447225\n",
      "24286.221563545107 8500\n",
      "diversificacion\n",
      "[] 30844.46923039888\n",
      "24286.221563545107 9000\n",
      "diversificacion\n",
      "[] 32455.281734731394\n",
      "24286.221563545107 9500\n",
      "intensificacion\n",
      "[] 24286.221563545107\n",
      "Tiempo iteracion:  323.13595366477966\n",
      "sin :  [42, 19, 24, 11, 101, 103, 85, 45, 107, 91, 58, 52, 113, 119, 84, 86, 27, 117, 54, 41, 56, 32, 7, 77, 23, 3, 9, 20, 87, 72, 66, 95, 68, 116, 105, 1, 100, 34, 21, 98, 18, 65, 73, 17, 94, 78, 64, 50, 70, 61, 46, 10, 31, 69, 83, 30, 38, 71, 114, 43, 59, 75, 82, 93, 74, 29, 104, 63, 81, 96, 102, 26, 47, 14, 97, 13, 49, 36, 118, 51, 60, 40, 48, 35, 88, 33, 44, 99, 67, 111, 80, 112, 108, 8, 22, 39, 2, 89, 110, 12, 28, 25, 53, 109, 106, 79, 15, 92, 55, 115, 4, 6, 62, 76, 90, 5, 37, 57, 16]\n",
      "185610.92628926464 0\n",
      "39326.95745608165 500\n",
      "37612.13546057725 1000\n",
      "diversificacion\n",
      "[] 28230.234276290586\n",
      "26369.613463006863 1500\n",
      "26295.759147582998 2000\n",
      "diversificacion\n",
      "[] 30152.461937195465\n",
      "26295.759147582998 2500\n",
      "diversificacion\n",
      "[] 31752.281386156716\n",
      "26295.759147582998 3000\n",
      "diversificacion\n",
      "[] 29351.084937427568\n",
      "25740.601060970967 3500\n",
      "diversificacion\n",
      "[] 30729.389904279116\n",
      "25740.601060970967 4000\n",
      "intensificacion\n",
      "[] 25740.601060970967\n",
      "25726.112655022367 4500\n",
      "diversificacion\n",
      "[] 29760.51223665101\n",
      "25726.112655022367 5000\n",
      "diversificacion\n",
      "[] 27400.01321789437\n",
      "25223.172900532903 5500\n",
      "24952.419518361527 6000\n",
      "diversificacion\n",
      "[] 31497.142047132704\n",
      "24952.419518361527 6500\n",
      "intensificacion\n",
      "[] 24952.419518361527\n",
      "24521.084983585606 7000\n",
      "diversificacion\n",
      "[] 29776.924059471807\n",
      "24521.084983585606 7500\n",
      "diversificacion\n",
      "[] 30498.166220432027\n",
      "24521.084983585606 8000\n",
      "diversificacion\n",
      "[] 30029.574593285906\n",
      "24521.084983585606 8500\n",
      "intensificacion\n",
      "[] 24521.084983585606\n",
      "24521.084983585606 9000\n",
      "diversificacion\n",
      "[] 30379.75292766802\n",
      "24521.084983585606 9500\n",
      "intensificacion\n",
      "[] 24521.084983585606\n",
      "Tiempo iteracion:  323.1531460285187\n",
      "sin :  [115, 99, 68, 89, 87, 80, 55, 11, 101, 52, 83, 13, 64, 20, 82, 23, 66, 106, 50, 39, 75, 48, 27, 58, 67, 28, 59, 16, 22, 36, 119, 88, 107, 51, 53, 10, 109, 84, 73, 57, 71, 35, 102, 37, 42, 32, 46, 8, 62, 92, 78, 44, 61, 56, 45, 9, 79, 26, 25, 6, 43, 29, 18, 108, 116, 40, 72, 24, 54, 4, 111, 103, 60, 86, 2, 97, 33, 63, 117, 30, 114, 3, 113, 76, 14, 38, 74, 49, 17, 21, 1, 47, 5, 100, 110, 105, 95, 70, 85, 15, 96, 91, 93, 19, 81, 112, 12, 77, 98, 7, 94, 90, 41, 34, 69, 104, 65, 31, 118]\n",
      "185957.79825244276 0\n",
      "39219.32288209027 500\n",
      "36137.49677015984 1000\n",
      "35053.37838198189 1500\n",
      "34082.98081334374 2000\n",
      "34077.64193575651 2500\n",
      "diversificacion\n",
      "[] 27710.12403389432\n",
      "25851.281148163067 3000\n",
      "diversificacion\n",
      "[] 29477.32407207527\n",
      "25851.281148163067 3500\n",
      "diversificacion\n",
      "[] 31112.91786765627\n",
      "25851.281148163067 4000\n",
      "intensificacion\n",
      "[] 25851.281148163067\n",
      "25799.082491834884 4500\n",
      "diversificacion\n",
      "[] 28126.29527733668\n",
      "24143.574302558212 5000\n",
      "diversificacion\n",
      "[] 29803.539999157423\n",
      "24143.574302558212 5500\n",
      "diversificacion\n",
      "[] 30721.882964292403\n",
      "24143.574302558212 6000\n",
      "intensificacion\n",
      "[] 24143.574302558212\n",
      "24102.322796188328 6500\n",
      "diversificacion\n",
      "[] 27931.17986475245\n",
      "24102.322796188328 7000\n",
      "diversificacion\n",
      "[] 28020.076244541797\n",
      "24102.322796188328 7500\n",
      "diversificacion\n",
      "[] 28284.67201742084\n",
      "24102.322796188328 8000\n",
      "intensificacion\n",
      "[] 24102.322796188328\n",
      "24102.322796188328 8500\n",
      "intensificacion\n",
      "[] 24102.322796188328\n",
      "24102.322796188328 9000\n",
      "diversificacion\n",
      "[] 31768.477464918044\n",
      "24102.322796188328 9500\n",
      "diversificacion\n",
      "[] 29373.40011040362\n",
      "Tiempo iteracion:  324.9400224685669\n"
     ]
    }
   ],
   "source": [
    "import time\n",
    "import numpy as np\n",
    "g5=Localizaciones(filename='./data/US120.txt') \n",
    "soluciones = []\n",
    "costes = []\n",
    "iteracion = []\n",
    "tiempos = []\n",
    "for i in range(3):\n",
    "    inicial = time.time()\n",
    "    sol = busqueda_tabu(g5, 120, 100, 10000)\n",
    "    final = time.time()\n",
    "    print(\"Tiempo iteracion: \", final-inicial)\n",
    "    soluciones.append(sol[0])\n",
    "    costes.append(funcion_coste(sol[0],g5))\n",
    "    iteracion.append(sol[1])\n",
    "    tiempos.append(final - inicial)\n",
    "    \n",
    "np.save('soluciones_oscilacion.npy', np.array(soluciones))\n",
    "np.save('costes_oscilacion.npy', np.array(costes))\n",
    "np.save('iteracion_oscilacion.npy', np.array(iteracion))\n",
    "np.save('tiempos_oscilacion.npy', np.array(tiempos))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 323,
   "id": "44761c4b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Media de costes:  24303.209781106347\n",
      "Desviacion:  209.89733693015108\n",
      "Minimo:  24102.322796188328\n",
      "Maximo:  24521.084983585606\n",
      "Media de tiempos:  323.74304072062176\n",
      "Desviacion:  1.0366522430536207\n",
      "Tiempo de la mejor solucion:  324.9400224685669\n",
      "Media de iteracion:  7185\n",
      "Desviacion:  992.7754025961764\n",
      "Iteracion de la mejor solucion:  6358\n"
     ]
    }
   ],
   "source": [
    "import statistics\n",
    "tiempos = np.load(\"tiempos_oscilacion.npy\")\n",
    "costes = np.load(\"costes_oscilacion.npy\")\n",
    "iteracion = np.load(\"iteracion_oscilacion.npy\")\n",
    "\n",
    "print(\"Media de costes: \", statistics.mean(costes))\n",
    "print(\"Desviacion: \", statistics.stdev(costes))\n",
    "print(\"Minimo: \", min(costes))\n",
    "print(\"Maximo: \", max(costes))\n",
    "print(\"Media de tiempos: \", statistics.mean(tiempos))\n",
    "print(\"Desviacion: \", statistics.stdev(tiempos))\n",
    "print(\"Tiempo de la mejor solucion: \", tiempos[list(costes).index(min(costes))])\n",
    "print(\"Media de iteracion: \", statistics.mean(iteracion))\n",
    "print(\"Desviacion: \", statistics.stdev(iteracion))\n",
    "print(\"Iteracion de la mejor solucion: \", iteracion[list(costes).index(min(costes))])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 307,
   "id": "e2ba96db",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sin :  [11, 39, 41, 10, 64, 40, 48, 69, 74, 113, 115, 68, 16, 24, 85, 8, 105, 81, 38, 58, 88, 20, 95, 56, 104, 119, 43, 27, 17, 44, 98, 118, 117, 108, 23, 78, 89, 97, 13, 25, 79, 14, 102, 114, 72, 100, 5, 21, 55, 96, 101, 94, 49, 109, 80, 110, 22, 26, 66, 50, 9, 84, 103, 91, 112, 28, 37, 93, 30, 116, 70, 2, 71, 60, 107, 31, 4, 53, 61, 19, 51, 15, 45, 83, 106, 32, 42, 76, 67, 59, 18, 92, 57, 12, 1, 82, 46, 35, 65, 54, 63, 62, 47, 33, 77, 29, 87, 36, 99, 6, 90, 111, 7, 3, 73, 52, 34, 75, 86]\n",
      "187509.33913550156 0\n",
      "35587.86721971085 500\n",
      "32637.914157560925 1000\n",
      "32050.454271161783 1500\n",
      "31742.6832888755 2000\n",
      "31479.212885861038 2500\n",
      "31173.146236108085 3000\n",
      "29664.236329444044 3500\n",
      "29591.519592464705 4000\n",
      "intensificacion\n",
      "[] 29591.519592464705\n",
      "29129.408423938374 4500\n",
      "intensificacion\n",
      "[] 29129.408423938374\n",
      "29114.377961203092 5000\n",
      "intensificacion\n",
      "[] 29114.377961203092\n",
      "29114.377961203092 5500\n",
      "intensificacion\n",
      "[] 29114.377961203092\n",
      "29114.377961203092 6000\n",
      "diversificacion\n",
      "[] 31179.64668019182\n",
      "27640.684408147205 6500\n",
      "27435.993348889755 7000\n",
      "intensificacion\n",
      "[] 27435.993348889755\n",
      "27093.97204599534 7500\n",
      "diversificacion\n",
      "[] 29282.946811722726\n",
      "24165.702820847964 8000\n",
      "intensificacion\n",
      "[] 24165.702820847964\n",
      "24137.87696903145 8500\n",
      "diversificacion\n",
      "[] 29716.19515547419\n",
      "24137.87696903145 9000\n",
      "23753.688946286726 9500\n",
      "intensificacion\n",
      "[] 23753.688946286726\n",
      "Tiempo iteracion:  344.4773404598236\n",
      "sin :  [60, 61, 63, 118, 10, 76, 59, 18, 82, 48, 36, 16, 44, 22, 13, 58, 112, 102, 46, 81, 32, 47, 93, 74, 91, 92, 2, 56, 109, 27, 15, 20, 26, 43, 12, 67, 64, 23, 117, 14, 111, 65, 85, 34, 105, 83, 7, 25, 28, 19, 106, 1, 55, 77, 119, 113, 101, 42, 94, 110, 99, 104, 78, 70, 17, 100, 30, 97, 52, 50, 108, 31, 53, 71, 87, 45, 75, 54, 38, 41, 107, 89, 37, 103, 24, 8, 33, 69, 39, 79, 115, 116, 86, 35, 3, 80, 51, 73, 11, 40, 68, 98, 5, 6, 9, 72, 90, 88, 96, 21, 57, 49, 114, 66, 95, 62, 29, 84, 4]\n",
      "177436.54987300473 0\n",
      "36442.246793352635 500\n",
      "34015.459447295754 1000\n",
      "33664.060367232036 1500\n",
      "33122.48019455787 2000\n",
      "diversificacion\n",
      "[] 29562.413655930857\n",
      "27740.841711492467 2500\n",
      "intensificacion\n",
      "[] 27740.841711492467\n",
      "27398.503640724197 3000\n",
      "diversificacion\n",
      "[] 27316.662089846555\n",
      "23739.20873805596 3500\n",
      "intensificacion\n",
      "[] 23739.20873805596\n",
      "23705.82690160764 4000\n",
      "intensificacion\n",
      "[] 23705.82690160764\n",
      "23705.82690160764 4500\n",
      "diversificacion\n",
      "[] 29300.451320795608\n",
      "23705.82690160764 5000\n",
      "diversificacion\n",
      "[] 29518.93101914497\n",
      "23705.82690160764 5500\n",
      "diversificacion\n",
      "[] 28014.184017796964\n",
      "23705.82690160764 6000\n",
      "diversificacion\n",
      "[] 30741.233411371828\n",
      "23705.82690160764 6500\n",
      "intensificacion\n",
      "[] 23705.82690160764\n",
      "23705.82690160764 7000\n",
      "intensificacion\n",
      "[] 23705.82690160764\n",
      "23705.82690160764 7500\n",
      "intensificacion\n",
      "[] 23705.82690160764\n",
      "23705.82690160764 8000\n",
      "intensificacion\n",
      "[] 23705.82690160764\n",
      "23705.82690160764 8500\n",
      "diversificacion\n",
      "[] 29893.48525515403\n",
      "23705.82690160764 9000\n",
      "intensificacion\n",
      "[] 23705.82690160764\n",
      "23705.82690160764 9500\n",
      "intensificacion\n",
      "[] 23705.82690160764\n",
      "Tiempo iteracion:  340.3124408721924\n",
      "sin :  [51, 68, 117, 106, 113, 72, 25, 46, 98, 16, 45, 42, 73, 18, 50, 91, 10, 23, 76, 99, 110, 31, 35, 74, 59, 66, 60, 4, 107, 69, 52, 96, 92, 94, 93, 75, 15, 95, 55, 47, 62, 13, 3, 33, 24, 21, 49, 27, 82, 77, 70, 29, 58, 32, 67, 61, 12, 5, 109, 78, 108, 89, 86, 14, 57, 102, 87, 65, 8, 83, 114, 97, 17, 118, 40, 37, 41, 20, 48, 116, 90, 7, 79, 85, 38, 105, 34, 44, 26, 22, 104, 71, 111, 11, 36, 103, 6, 1, 56, 9, 80, 39, 64, 43, 28, 88, 19, 53, 112, 100, 115, 63, 81, 30, 84, 119, 2, 101, 54]\n",
      "180847.39773470635 0\n",
      "34942.42173827334 500\n",
      "33769.95752388805 1000\n",
      "intensificacion\n",
      "[] 33769.95752388805\n",
      "33552.2371162644 1500\n",
      "32489.759830649655 2000\n",
      "intensificacion\n",
      "[] 32489.759830649655\n",
      "32208.19169132494 2500\n",
      "diversificacion\n",
      "[] 29948.58179657597\n",
      "28078.561891470068 3000\n",
      "intensificacion\n",
      "[] 28078.561891470068\n",
      "28000.27343828358 3500\n",
      "27678.9845923749 4000\n",
      "27147.032950979654 4500\n",
      "intensificacion\n",
      "[] 27147.032950979654\n",
      "26697.158152573797 5000\n",
      "diversificacion\n",
      "[] 28761.61075754641\n",
      "26697.158152573797 5500\n",
      "diversificacion\n",
      "[] 31343.274183109253\n",
      "26697.158152573797 6000\n",
      "diversificacion\n",
      "[] 28897.104334279902\n",
      "26155.890745186112 6500\n",
      "diversificacion\n",
      "[] 28387.67962756317\n",
      "26155.890745186112 7000\n",
      "diversificacion\n",
      "[] 29768.41857851243\n",
      "26155.890745186112 7500\n",
      "diversificacion\n",
      "[] 30658.34317985971\n",
      "26155.890745186112 8000\n",
      "intensificacion\n",
      "[] 26155.890745186112\n",
      "26155.890745186112 8500\n",
      "diversificacion\n",
      "[] 31133.65094944062\n",
      "26155.890745186112 9000\n",
      "intensificacion\n",
      "[] 26155.890745186112\n",
      "26155.890745186112 9500\n",
      "diversificacion\n",
      "[] 29905.702474686717\n",
      "Tiempo iteracion:  344.5468280315399\n",
      "sin :  [118, 10, 102, 56, 82, 44, 63, 62, 26, 101, 6, 61, 50, 31, 2, 16, 49, 33, 81, 9, 80, 30, 18, 112, 24, 85, 106, 92, 96, 68, 60, 98, 36, 1, 91, 74, 66, 111, 42, 113, 32, 117, 84, 28, 110, 95, 47, 83, 23, 3, 53, 15, 48, 72, 43, 76, 86, 71, 90, 59, 12, 73, 55, 64, 119, 22, 105, 78, 107, 88, 7, 51, 45, 103, 27, 38, 104, 89, 87, 93, 21, 37, 13, 19, 4, 25, 114, 41, 5, 29, 67, 52, 79, 70, 11, 14, 94, 100, 65, 39, 34, 57, 54, 20, 109, 46, 40, 97, 17, 69, 116, 58, 35, 108, 99, 115, 8, 75, 77]\n",
      "192193.1906490045 0\n",
      "47058.296012190716 500\n",
      "44300.85442445648 1000\n",
      "38806.34721356681 1500\n",
      "37757.324524398595 2000\n",
      "37039.53782141363 2500\n",
      "36072.307784674726 3000\n",
      "34029.876953349725 3500\n",
      "intensificacion\n",
      "[] 34029.876953349725\n",
      "33796.4263953236 4000\n",
      "diversificacion\n",
      "[] 31952.08434773554\n",
      "28289.132591645335 4500\n",
      "diversificacion\n",
      "[] 31545.01754881437\n",
      "28289.132591645335 5000\n",
      "intensificacion\n",
      "[] 28289.132591645335\n",
      "28286.031698102845 5500\n",
      "diversificacion\n",
      "[] 31361.008835322467\n",
      "28286.031698102845 6000\n",
      "intensificacion\n",
      "[] 28286.031698102845\n",
      "28286.031698102845 6500\n",
      "diversificacion\n",
      "[] 30235.102549556905\n",
      "27598.950403394632 7000\n",
      "diversificacion\n",
      "[] 30688.296010930393\n",
      "27598.950403394632 7500\n",
      "intensificacion\n",
      "[] 27598.950403394632\n",
      "27523.189067451764 8000\n",
      "diversificacion\n",
      "[] 32668.625620824132\n",
      "27523.189067451764 8500\n",
      "diversificacion\n",
      "[] 29831.45239375258\n",
      "27523.189067451764 9000\n",
      "27235.75624986974 9500\n",
      "Tiempo iteracion:  341.80469965934753\n",
      "sin :  [1, 32, 112, 17, 109, 64, 50, 103, 14, 57, 19, 23, 28, 101, 35, 117, 51, 12, 94, 97, 20, 52, 115, 56, 68, 42, 49, 114, 119, 40, 39, 37, 60, 48, 118, 82, 54, 53, 16, 81, 69, 93, 34, 4, 98, 107, 104, 74, 22, 27, 75, 79, 25, 72, 96, 90, 41, 45, 116, 6, 18, 80, 7, 105, 44, 66, 86, 55, 24, 59, 110, 36, 62, 87, 46, 91, 78, 10, 77, 67, 13, 89, 85, 113, 106, 84, 95, 8, 83, 58, 88, 70, 33, 61, 76, 21, 3, 26, 43, 31, 38, 30, 100, 102, 65, 71, 63, 5, 29, 47, 9, 73, 11, 111, 15, 92, 99, 108, 2]\n",
      "179066.3116462204 0\n",
      "41162.34517421787 500\n",
      "35333.55979272578 1000\n",
      "34486.10216132944 1500\n",
      "34103.88592806792 2000\n",
      "31536.469267327087 2500\n",
      "30983.68759140727 3000\n",
      "30631.58868205943 3500\n",
      "30337.51036539048 4000\n",
      "diversificacion\n",
      "[] 30921.685234517274\n",
      "28884.58006346739 4500\n",
      "28088.77855559241 5000\n",
      "diversificacion\n",
      "[] 29812.151398347778\n",
      "27452.33232369129 5500\n",
      "diversificacion\n",
      "[] 29537.246855676607\n",
      "27004.56425024036 6000\n",
      "intensificacion\n",
      "[] 27004.56425024036\n",
      "27000.149779354437 6500\n",
      "diversificacion\n",
      "[] 30135.912603517765\n",
      "27000.149779354437 7000\n",
      "intensificacion\n",
      "[] 27000.149779354437\n",
      "27000.149779354437 7500\n",
      "26963.88285225073 8000\n",
      "intensificacion\n",
      "[] 26963.88285225073\n",
      "26779.279587887464 8500\n",
      "intensificacion\n",
      "[] 26779.279587887464\n",
      "26779.279587887464 9000\n",
      "diversificacion\n",
      "[] 29422.920103441906\n",
      "26779.279587887464 9500\n",
      "diversificacion\n",
      "[] 30081.75343069443\n",
      "Tiempo iteracion:  341.01982498168945\n",
      "sin :  [56, 27, 57, 97, 24, 93, 58, 101, 89, 110, 1, 54, 117, 23, 100, 9, 49, 99, 112, 7, 44, 96, 106, 3, 84, 35, 11, 98, 118, 50, 22, 65, 67, 109, 55, 42, 64, 90, 81, 104, 25, 94, 19, 61, 37, 5, 40, 111, 43, 69, 52, 114, 39, 6, 12, 14, 45, 102, 21, 10, 108, 32, 76, 119, 66, 18, 79, 77, 26, 82, 115, 59, 113, 31, 34, 2, 75, 83, 87, 47, 41, 105, 38, 36, 68, 103, 60, 46, 28, 107, 95, 8, 73, 91, 70, 72, 33, 4, 13, 78, 62, 17, 80, 116, 29, 85, 30, 63, 15, 86, 53, 20, 51, 48, 88, 74, 92, 16, 71]\n",
      "168822.58732711308 0\n",
      "38762.60472886229 500\n",
      "37330.14017710178 1000\n",
      "36287.79764736043 1500\n",
      "36269.33767287774 2000\n",
      "diversificacion\n",
      "[] 31408.440053304847\n",
      "28008.12187334751 2500\n",
      "27454.109572576228 3000\n",
      "27330.55696925058 3500\n",
      "intensificacion\n",
      "[] 27330.55696925058\n",
      "27039.441976520375 4000\n",
      "intensificacion\n",
      "[] 27039.441976520375\n",
      "27039.441976520375 4500\n",
      "diversificacion\n",
      "[] 28327.706765549017\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "26186.24236817187 5000\n",
      "intensificacion\n",
      "[] 26186.24236817187\n",
      "26101.62523244969 5500\n",
      "diversificacion\n",
      "[] 31537.714276244067\n",
      "26101.62523244969 6000\n",
      "intensificacion\n",
      "[] 26101.62523244969\n",
      "26101.62523244969 6500\n",
      "intensificacion\n",
      "[] 26101.62523244969\n",
      "26101.62523244969 7000\n",
      "diversificacion\n",
      "[] 30554.36516383679\n",
      "26101.62523244969 7500\n",
      "intensificacion\n",
      "[] 26101.62523244969\n",
      "26101.62523244969 8000\n",
      "intensificacion\n",
      "[] 26101.62523244969\n",
      "26101.62523244969 8500\n",
      "diversificacion\n",
      "[] 29784.592418622848\n",
      "26101.62523244969 9000\n",
      "diversificacion\n",
      "[] 30690.226776288455\n",
      "26101.62523244969 9500\n",
      "diversificacion\n",
      "[] 28688.54809028449\n",
      "Tiempo iteracion:  340.7727189064026\n",
      "sin :  [12, 74, 88, 1, 98, 70, 2, 66, 80, 71, 59, 96, 23, 95, 30, 115, 97, 69, 38, 90, 53, 100, 73, 94, 43, 119, 87, 86, 81, 6, 114, 60, 5, 89, 41, 4, 29, 16, 104, 75, 116, 54, 92, 52, 11, 76, 49, 27, 99, 32, 28, 107, 45, 20, 26, 14, 34, 37, 15, 77, 24, 7, 47, 51, 108, 3, 101, 21, 58, 84, 111, 67, 93, 106, 78, 103, 55, 42, 8, 39, 17, 118, 64, 65, 82, 22, 40, 68, 61, 79, 110, 85, 56, 10, 13, 9, 102, 31, 112, 117, 109, 83, 62, 36, 57, 72, 91, 50, 18, 48, 35, 19, 113, 44, 105, 63, 33, 25, 46]\n",
      "185397.12784037032 0\n",
      "35800.16834906083 500\n",
      "33655.335219139844 1000\n",
      "32921.20106717156 1500\n",
      "intensificacion\n",
      "[] 32921.20106717156\n",
      "32760.087230567093 2000\n",
      "intensificacion\n",
      "[] 32760.087230567093\n",
      "32760.087230567093 2500\n",
      "diversificacion\n",
      "[] 29595.889658097614\n",
      "26474.76122614137 3000\n",
      "26017.78176500835 3500\n",
      "diversificacion\n",
      "[] 30292.65037005601\n",
      "26017.78176500835 4000\n",
      "diversificacion\n",
      "[] 28118.80365797162\n",
      "25961.562740759367 4500\n",
      "diversificacion\n",
      "[] 28994.730455420922\n",
      "25961.562740759367 5000\n",
      "intensificacion\n",
      "[] 25961.562740759367\n",
      "25737.93914717508 5500\n",
      "intensificacion\n",
      "[] 25737.93914717508\n",
      "25737.93914717508 6000\n",
      "diversificacion\n",
      "[] 29816.16834232544\n",
      "25737.93914717508 6500\n",
      "intensificacion\n",
      "[] 25737.93914717508\n",
      "25737.93914717508 7000\n",
      "diversificacion\n",
      "[] 29791.802093207094\n",
      "25737.93914717508 7500\n",
      "diversificacion\n",
      "[] 30516.420679667215\n",
      "25737.93914717508 8000\n",
      "intensificacion\n",
      "[] 25737.93914717508\n",
      "25737.93914717508 8500\n",
      "diversificacion\n",
      "[] 31278.53827653034\n",
      "25737.93914717508 9000\n",
      "intensificacion\n",
      "[] 25737.93914717508\n",
      "25737.93914717508 9500\n",
      "intensificacion\n",
      "[] 25737.93914717508\n",
      "Tiempo iteracion:  337.2305414676666\n",
      "sin :  [73, 58, 75, 59, 31, 100, 21, 116, 25, 8, 28, 95, 104, 46, 45, 11, 27, 69, 7, 106, 108, 68, 39, 80, 20, 117, 115, 36, 54, 10, 62, 103, 3, 111, 101, 52, 92, 96, 2, 102, 43, 56, 78, 82, 112, 48, 13, 81, 35, 107, 18, 17, 37, 22, 47, 50, 118, 14, 12, 38, 44, 9, 72, 6, 119, 40, 63, 24, 105, 89, 113, 74, 29, 84, 87, 32, 51, 57, 88, 15, 86, 53, 5, 19, 110, 109, 67, 34, 61, 49, 66, 83, 79, 70, 77, 91, 33, 64, 76, 90, 97, 55, 4, 30, 16, 65, 42, 26, 93, 99, 85, 1, 94, 114, 60, 41, 23, 98, 71]\n",
      "184334.06999845436 0\n",
      "40631.2785459173 500\n",
      "36207.558579776996 1000\n",
      "34144.42338262411 1500\n",
      "33674.732150291806 2000\n",
      "33433.19183876401 2500\n",
      "33271.67133538199 3000\n",
      "32854.965212918534 3500\n",
      "intensificacion\n",
      "[] 32854.965212918534\n",
      "32412.003595609734 4000\n",
      "intensificacion\n",
      "[] 32412.003595609734\n",
      "32361.856327137542 4500\n",
      "diversificacion\n",
      "[] 31221.098331168963\n",
      "28435.781639639943 5000\n",
      "28299.72761073165 5500\n",
      "intensificacion\n",
      "[] 28299.72761073165\n",
      "28185.76876382581 6000\n",
      "intensificacion\n",
      "[] 28185.76876382581\n",
      "28185.76876382581 6500\n",
      "diversificacion\n",
      "[] 32868.979855743666\n",
      "28185.76876382581 7000\n",
      "intensificacion\n",
      "[] 28185.76876382581\n",
      "28185.76876382581 7500\n",
      "diversificacion\n",
      "[] 32859.67390087117\n",
      "28185.76876382581 8000\n",
      "diversificacion\n",
      "[] 28967.737594849707\n",
      "23995.86385066396 8500\n",
      "23884.344554882704 9000\n",
      "23832.45661799806 9500\n",
      "diversificacion\n",
      "[] 30020.6526328627\n",
      "Tiempo iteracion:  336.5312180519104\n",
      "sin :  [97, 23, 57, 59, 78, 39, 55, 107, 74, 95, 44, 75, 1, 100, 35, 17, 86, 30, 101, 13, 110, 26, 24, 45, 15, 92, 56, 46, 94, 99, 12, 87, 11, 60, 42, 119, 88, 103, 5, 54, 104, 2, 72, 28, 48, 83, 21, 112, 7, 102, 115, 69, 40, 14, 52, 82, 116, 117, 111, 66, 47, 36, 8, 33, 22, 77, 18, 4, 79, 71, 63, 16, 73, 105, 50, 49, 108, 10, 61, 70, 65, 93, 29, 114, 41, 98, 84, 109, 51, 3, 91, 43, 25, 113, 81, 76, 32, 37, 34, 118, 68, 80, 9, 27, 31, 85, 19, 53, 90, 20, 6, 67, 106, 96, 38, 89, 64, 62, 58]\n",
      "173197.41458479507 0\n",
      "44260.07519153395 500\n",
      "40897.09332741625 1000\n",
      "39019.78475017423 1500\n",
      "38901.145442775116 2000\n",
      "38612.771706232204 2500\n",
      "38438.17736333556 3000\n",
      "38335.73918259522 3500\n",
      "38290.99609913657 4000\n",
      "diversificacion\n",
      "[] 28686.10300522015\n",
      "26776.91366592904 4500\n",
      "diversificacion\n",
      "[] 29357.615245007335\n",
      "26776.91366592904 5000\n",
      "diversificacion\n",
      "[] 30203.50505254347\n",
      "26776.91366592904 5500\n",
      "intensificacion\n",
      "[] 26776.91366592904\n",
      "26721.938103874054 6000\n",
      "intensificacion\n",
      "[] 26721.938103874054\n",
      "26396.17961336839 6500\n",
      "diversificacion\n",
      "[] 29499.903835793113\n",
      "26396.17961336839 7000\n",
      "intensificacion\n",
      "[] 26396.17961336839\n",
      "26396.17961336839 7500\n",
      "diversificacion\n",
      "[] 32399.76109511243\n",
      "26396.17961336839 8000\n",
      "intensificacion\n",
      "[] 26396.17961336839\n",
      "26396.17961336839 8500\n",
      "diversificacion\n",
      "[] 31566.592207052316\n",
      "26396.17961336839 9000\n",
      "intensificacion\n",
      "[] 26396.17961336839\n",
      "26396.17961336839 9500\n",
      "diversificacion\n",
      "[] 31163.274806701447\n",
      "Tiempo iteracion:  336.642906665802\n",
      "sin :  [81, 6, 55, 117, 79, 100, 7, 54, 3, 4, 22, 51, 97, 43, 102, 23, 29, 80, 110, 45, 85, 68, 38, 26, 92, 69, 1, 73, 10, 35, 53, 52, 37, 40, 104, 17, 58, 34, 36, 116, 78, 74, 18, 83, 9, 76, 59, 115, 42, 112, 108, 12, 20, 89, 15, 25, 86, 101, 105, 30, 109, 75, 113, 24, 41, 91, 21, 28, 56, 106, 11, 31, 47, 98, 8, 119, 67, 103, 62, 111, 49, 48, 50, 60, 5, 87, 90, 27, 96, 114, 99, 33, 2, 118, 66, 71, 46, 93, 61, 64, 57, 72, 94, 14, 63, 16, 77, 65, 82, 107, 39, 32, 13, 84, 19, 70, 44, 95, 88]\n",
      "177263.64753159607 0\n",
      "37206.50324382143 500\n",
      "36800.117296768105 1000\n",
      "34645.309288176366 1500\n",
      "34315.3775459542 2000\n",
      "34092.72467726194 2500\n",
      "33007.45775046362 3000\n",
      "diversificacion\n",
      "[] 27653.952918023355\n",
      "24892.887897549983 3500\n",
      "diversificacion\n",
      "[] 27564.939223764464\n",
      "24892.887897549983 4000\n",
      "intensificacion\n",
      "[] 24892.887897549983\n",
      "24697.262332921837 4500\n",
      "diversificacion\n",
      "[] 29021.06257444643\n",
      "24697.262332921837 5000\n",
      "diversificacion\n",
      "[] 28682.594663409433\n",
      "24697.262332921837 5500\n",
      "intensificacion\n",
      "[] 24697.262332921837\n",
      "24697.262332921837 6000\n",
      "intensificacion\n",
      "[] 24697.262332921837\n",
      "24697.262332921837 6500\n",
      "intensificacion\n",
      "[] 24697.262332921837\n",
      "24697.262332921837 7000\n",
      "diversificacion\n",
      "[] 29861.41253067096\n",
      "24697.262332921837 7500\n",
      "intensificacion\n",
      "[] 24697.262332921837\n",
      "24697.262332921837 8000\n",
      "diversificacion\n",
      "[] 30920.479654771636\n",
      "24697.262332921837 8500\n",
      "intensificacion\n",
      "[] 24697.262332921837\n",
      "24697.262332921837 9000\n",
      "intensificacion\n",
      "[] 24697.262332921837\n",
      "24697.262332921837 9500\n",
      "intensificacion\n",
      "[] 24697.262332921837\n",
      "Tiempo iteracion:  339.28990507125854\n"
     ]
    }
   ],
   "source": [
    "import time\n",
    "import numpy as np\n",
    "g5=Localizaciones(filename='./data/US120.txt') \n",
    "soluciones = []\n",
    "costes = []\n",
    "iteracion = []\n",
    "tiempos = []\n",
    "for i in range(10):\n",
    "    inicial = time.time()\n",
    "    sol = busqueda_tabu(g5, 120, 100, 10000)\n",
    "    final = time.time()\n",
    "    print(\"Tiempo iteracion: \", final-inicial)\n",
    "    soluciones.append(sol[0])\n",
    "    costes.append(funcion_coste(sol[0],g5))\n",
    "    iteracion.append(sol[1])\n",
    "    tiempos.append(final - inicial)\n",
    "    \n",
    "np.save('soluciones_oscilacion_ultima.npy', np.array(soluciones))\n",
    "np.save('costes_oscilacion_ultima.npy', np.array(costes))\n",
    "np.save('iteracion_oscilacion_ultima.npy', np.array(iteracion))\n",
    "np.save('tiempos_oscilacion_ultima.npy', np.array(tiempos))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 349,
   "id": "84dd7949",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mejor solucion:  [101, 79, 51, 91, 81, 109, 119, 83, 69, 82, 89, 8, 38, 40, 105, 36, 35, 94, 18, 16, 59, 4, 42, 71, 110, 113, 14, 11, 58, 55, 21, 62, 75, 63, 41, 24, 26, 23, 52, 117, 92, 34, 60, 47, 9, 20, 111, 49, 25, 17, 103, 96, 70, 73, 88, 31, 72, 5, 87, 112, 54, 95, 85, 104, 46, 33, 108, 48, 97, 57, 6, 45, 30, 44, 102, 76, 39, 29, 116, 118, 15, 67, 12, 115, 106, 1, 61, 98, 99, 56, 19, 7, 27, 86, 65, 93, 28, 66, 3, 53, 50, 64, 74, 37, 84, 2, 13, 78, 80, 114, 107, 22, 68, 100, 90, 43, 32, 10, 77]\n",
      "Media de costes:  25217.226980678206\n",
      "Desviacion:  1325.378567926485\n",
      "Minimo:  23343.592238113346\n",
      "Maximo:  26822.890982492267\n",
      "Media de tiempos:  340.2628424167633\n",
      "Desviacion:  2.915432467820047\n",
      "Tiempo de la mejor solucion:  344.4773404598236\n",
      "Media de iteracion:  7341\n",
      "Desviacion:  2326.859901240296\n",
      "Iteracion de la mejor solucion:  9938\n"
     ]
    }
   ],
   "source": [
    "import statistics\n",
    "tiempos = np.load(\"tiempos_oscilacion_ultima.npy\")\n",
    "costes = np.load(\"costes_oscilacion_ultima.npy\")\n",
    "iteracion = np.load(\"iteracion_oscilacion_ultima.npy\")\n",
    "soluciones = np.load(\"soluciones_oscilacion_ultima.npy\")\n",
    "\n",
    "print(\"Mejor solucion: \", list(soluciones[list(costes).index(min(costes))]))\n",
    "\n",
    "print(\"Media de costes: \", statistics.mean(costes))\n",
    "print(\"Desviacion: \", statistics.stdev(costes))\n",
    "print(\"Minimo: \", min(costes))\n",
    "print(\"Maximo: \", max(costes))\n",
    "print(\"Media de tiempos: \", statistics.mean(tiempos))\n",
    "print(\"Desviacion: \", statistics.stdev(tiempos))\n",
    "print(\"Tiempo de la mejor solucion: \", tiempos[list(costes).index(min(costes))])\n",
    "print(\"Media de iteracion: \", statistics.mean(iteracion))\n",
    "print(\"Desviacion: \", statistics.stdev(iteracion))\n",
    "print(\"Iteracion de la mejor solucion: \", iteracion[list(costes).index(min(costes))])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
